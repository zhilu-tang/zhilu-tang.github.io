{"pageProps":{"postsMetaData":[{"metadata":{"title":"Daily Thought Fallacies","description":"A case study about a trapped thought process.","imgName":"daily-thought-fallacies/daily-thought-fallacies.png","date":"Jul 1, 2025","tags":["algorithm","thought-process"],"keywords":["trap","algorithm","thought"],"id":"daily-thought-fallacies"},"content":"![Daily thought fallacies](daily-thought-fallacies/daily-thought-fallacies.png)\n \n###### Published on: **Jul 1, 2025**\n\n# 问题\n## 评价下面代码的整体思路、关键实现对错\n```java\n    static int[][] fh;\n    public int trapRainWaterWA2(int[][] heightMap) {\n        fh = heightMap;\n        int m = heightMap.length, n = heightMap[0].length;\n        int dir[] = {1,0,-1,0,1};\n        int ans = 0;\n        record Cell(int i, int j) implements Comparable<Cell>{\n            public int compareTo(Cell o){\n                return fh[i][j] - fh[o.i][o.j];\n            }\n        }\n        PriorityQueue<Cell> pq = new PriorityQueue<Cell>();\n        boolean used[][] = new boolean[m][n], visited[][];\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(!used[i][j]){\n                    pq.clear();\n                    visited = new boolean[m][n];\n                    // start\n                    var start = new Cell(i,j);\n                    pq.offer(start);\n                    visited[i][j] = true;\n                    used[i][j] = true;\n                    int bottom = heightMap[i][j], count = 0;\n                    while(!pq.isEmpty()){\n                        var c = pq.poll();\n                        int curh = heightMap[c.i][c.j];\n                        if(curh > bottom){\n                            ans += (curh - bottom) * count;\n                            bottom = curh;\n                        }\n                        if(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1)break;\n                        if(!used[c.i][c.j]){\n                            count++;\n                        }\n                        used[c.i][c.j] = true;\n                        for(int d = 0; d<4; d++){\n                            int x = c.i+dir[d], y = c.j+dir[d+1];\n                            if(x < 0 || y < 0 || x >= m || y >= n || visited[x][y])continue;\n                            visited[x][y] = true;\n                            pq.offer(new Cell(x, y));\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n```\n# 解答\nThe code attempts to solve the **Trapping Rain Water II** problem, where water can be trapped in a 2D elevation map. However, the implementation contains several **logical and structural errors**, which prevent it from working correctly.\n\n---\n\n## ✅ Overall Idea\n\nThe idea is based on using a **priority queue (min-heap)** to simulate the process of water flowing from the boundary inward, similar to Dijkstra's algorithm:\n\n- Start from the **border cells** as boundaries cannot trap water.\n- Use a **min-heap** to always process the lowest height cell next.\n- As you expand inward, any lower area surrounded by higher walls can potentially trap water.\n\nThis is a valid approach for this problem.\n\n---\n\n## ❌ Key Implementation Errors\n\n### 1. **Incorrect BFS/Heap Usage**\n```java\nif(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1) break;\n```\n- This line breaks the search when reaching any border cell.\n- **Problem**: The algorithm should start from the borders and explore inward. Instead, it stops as soon as it reaches a border, effectively ignoring the correct flow logic.\n\n### 2. **Misuse of `used` and `visited`**\n- `used` seems to mark whether a cell has been processed globally, while `visited` is reinitialized in each loop.\n- **Problem**: The inner BFS (`pq`) is not tracking global visited status properly, leading to:\n  - Re-processing of already visited regions.\n  - Incomplete traversal.\n\n### 3. **Wrong Calculation of Trapped Water**\n```java\nif(!used[c.i][c.j]){\n    count++;\n}\n```\n- `count` is used to track how many cells are in the current basin.\n- **Problem**: It doesn't account for the actual volume of water trapped per unit height difference correctly.\n- Also, `used[i][j] = true;` is set after checking, which may cause incorrect counting.\n\n### 4. **Use of Local Class Inside Method (Java 16+ only)**\n```java\nrecord Cell(int i, int j) implements Comparable<Cell>\n```\n- **Issue**: This uses a local record inside a method, which is only supported in Java 16+. If the environment supports it, that's fine, but if not, it will fail to compile.\n\nAlso, the `compareTo` method uses `fh[i][j]`, but `fh` is a class-level variable (`this.fh`). This could lead to confusion or bugs if `fh` changes during execution.\n\n### 5. **Redundant Outer Loop**\n- The outer double loop over all `(i,j)` is unnecessary.\n- **Correct approach**: Initialize the heap with all border cells first, then expand inward — no need to re-start BFS from every unvisited cell.\n\n---\n\n## 🛠️ Suggested Fixes\n\n### ✔️ Corrected Algorithm Outline\n\n1. **Initialize a min-heap** with all the border cells.\n2. Maintain a global `visited` matrix.\n3. While the heap is not empty:\n   - Pop the lowest cell.\n   - For its four neighbors:\n     - If not visited:\n       - If neighbor is lower than current height, it can trap water.\n       - Add neighbor to the heap with its own height.\n4. Accumulate trapped water accordingly.\n\n### ✔️ Code Skeleton Fix\n\n```java\npublic int trapRainWater(int[][] heightMap) {\n    if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)\n        return 0;\n\n    int m = heightMap.length, n = heightMap[0].length;\n    boolean[][] visited = new boolean[m][n];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // x, y, height\n    int[] dirs = {0, 1, 0, -1, 0};\n\n    // Initialize with boundary cells\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n                pq.offer(new int[]{i, j, heightMap[i][j]});\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    int res = 0;\n    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int maxHeight = 0;\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int x = curr[0], y = curr[1], h = curr[2];\n        maxHeight = Math.max(maxHeight, h);\n\n        for (int[] dir : directions) {\n            int nx = x + dir[0], ny = y + dir[1];\n            if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                if (heightMap[nx][ny] < maxHeight) {\n                    res += maxHeight - heightMap[nx][ny];\n                }\n                pq.offer(new int[]{nx, ny, Math.max(maxHeight, heightMap[nx][ny])});\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n---\n\n## ✅ Summary\n\n| Aspect | Evaluation |\n|-------|------------|\n| **Algorithm Design** | Partially correct conceptually, but flawed in implementation |\n| **Data Structures** | Priority Queue used incorrectly |\n| **Visited Tracking** | Confusing and incorrect |\n| **Water Calculation** | Incorrect logic |\n| **Code Structure** | Poor modularity and readability |\n\n---\n\n## 📌 Conclusion\n\nWhile the general idea of using a priority queue to simulate water flow is sound, the current implementation fails due to incorrect handling of visited nodes, early termination, and wrong calculation of trapped water. A revised version using a proper BFS-like approach with a min-heap and global visited tracking is necessary for correctness.\n\n# 问题 ：这种思维模式踩中了哪个误区？试着从更高维度分解这种思维模式的问题。（能够理解正确的做法是简洁的，模拟水位上涨逐渐淹没所有位置，第一次淹没时的高差，就是 trap 的水体积，正确的做法足够简洁清晰）。\nThis code's thought process falls into a **\"局部贪心 + 多重嵌套状态\"** thinking trap. It attempts to simulate the water trapping process by treating each basin separately and trying to compute local trapped water using nested loops and conditions.\n\n---\n\n## 🧠 高维思维模式分析（Higher-Level Pattern Analysis）\n\n### 1. **误区名称：局部模拟陷阱 / 分治式暴力（Local Simulation Fallacy）**\n\nThe developer tried to simulate water filling **locally**, assuming that each \"valley\" or enclosed area can be processed independently, starting from any unvisited cell.\n\n#### 🔍 特征：\n- 使用 `for` 循环从每个未访问的点出发，尝试“独立”处理。\n- 每次 BFS 都试图计算当前区域的积水体积。\n- 没有统一水位上涨模型，而是分块处理。\n\n#### ❌ 问题本质：\n- 忽视了全局水位逐渐上升这一物理过程。\n- 把问题拆解为多个子问题，反而引入复杂边界条件和重复计算。\n- 用 `used[][]` 和 `visited[][]` 来防止重复访问，但逻辑混乱导致错误。\n\n---\n\n### 2. **认知维度：没有抽象出核心变量（Failure to Abstract Core Variables）**\n\n正确的做法中，**maxHeight** 是一个核心抽象变量，它代表当前的“水位线”。\n\n#### ✅ 正确视角：\n- 所有积水都发生在某一点低于当前水位时。\n- 水位是单调不降的，随着优先队列弹出最小高度而逐步升高。\n- 每个点只被访问一次，避免重复判断和错误积累。\n\n#### ❌ 错误视角：\n- 没有建立“全局水位”的抽象，而是依赖局部比较（如 `curh > bottom`）。\n- 将 `bottom` 当作某种基准高度，但实际上它不具备全局一致性。\n- 没有意识到“第一次淹没”这个关键事件的价值。\n\n---\n\n### 3. **算法设计误区：忽视最优子结构（Ignoring Optimal Substructure）**\n\n这道题具有典型的**最短路径/最小堆扩展**性质：\n\n#### ✅ 正确方法的本质：\n- 利用最小堆维护当前最低边界。\n- 每次扩展最低点，确保当前水位是最小可淹没高度。\n- 类似于 Dijkstra 算法中的松弛操作。\n\n#### ❌ 错误方法的问题：\n- 没有利用优先队列的“最小高度优先”特性来驱动整个搜索流程。\n- 混合使用了 BFS、DFS 和贪心策略，导致状态失控。\n\n---\n\n## 🧩 思维模式高维分解图\n\n| 维度 | 错误模式 | 正确模式 |\n|------|----------|-----------|\n| **抽象层级** | 局部模拟，缺乏统一水位抽象 | 全局水位上涨模型 |\n| **控制流结构** | 多层嵌套循环 + 多重条件分支 | 单一优先队列驱动流程 |\n| **数据结构使用** | 堆仅用于局部搜索 | 堆驱动全局扩展顺序 |\n| **访问机制** | 双重 visited 控制，逻辑混乱 | 单一 visited + 最早访问即最早淹没 |\n| **问题建模方式** | 分治处理每个“坑” | 整体地形洪水模拟 |\n\n---\n\n## 🧭 认知升级建议\n\n要跳出这类思维误区，可以尝试以下思维方式：\n\n### ✅ 1. **寻找核心抽象变量**\n- 在本题中，“当前水位”就是唯一重要的变量。\n- 所有操作都应该围绕它进行更新和比较。\n\n### ✅ 2. **用物理过程类比算法行为**\n- 想象真实的水慢慢上涨的过程。\n- 这样能自然引导出优先队列和水位递增的思路。\n\n### ✅ 3. **追求“事件驱动”的编程思想**\n- 每个点被访问时是一个“事件”，触发水位更新。\n- 而不是用循环去“强行”遍历所有可能。\n\n### ✅ 4. **简化问题而非复杂化处理**\n- 不要试图在代码里解决所有边界情况。\n- 如果一个问题看起来很复杂，那可能是建模方式错了。\n\n---\n\n## 🎯 结语\n\n这段代码本质上踩进了“**微观模拟陷阱**”：试图从细节上还原每一个积水场景，却忽略了整体系统的行为规律。真正的高效解法往往来源于对系统宏观行为的理解与建模。\n\n“聪明的算法不在于写得多复杂，而在于抓住那个最简单的物理规则。”"},{"metadata":{"title":"The Core Lies In Modeling","description":"Comparison of computer algorithm competitions and university-level mathematical or simulation modeling competitions","imgName":"modeling-as-a-core/modeling-as-a-core.png","date":"Jul 1, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","modeling","math"],"id":"modeling-as-a-core"},"content":"![The Core Lies In Modeling](modeling-as-a-core/modeling-as-a-core.png)\n \n###### Published on: **Jul 1, 2025**\n\nYes, the \"modeling\" in both computer algorithm competitions and university-level mathematical or simulation modeling competitions follows similar principles, though they differ in focus and application domains.\n\n### Key Similarities:\n1. **Problem Abstraction**:\n   - In both cases, the core lies in abstracting a real-world or problem scenario into a simplified **model**, which could be represented by variables, relationships, constraints, or rules.\n   \n2. **Use of Variables and Relationships**:\n   - In programming contests, you often define key variables (e.g., `dp[i][j]` for dynamic programming) to capture states.\n   - In university modeling contests, you similarly define variables (e.g., `x(t)` for time-dependent systems) and relationships (e.g., differential equations, statistical models).\n\n3. **Mathematical or Logical Formulation**:\n   - Both require translating the problem into a precise formulation—be it an algorithmic model, a mathematical equation system, or a graph structure.\n\n4. **Computational Tools/Data Structures**:\n   - After building the model, appropriate data structures (like trees, graphs, arrays) or computational tools (like MATLAB, Python, or optimization libraries) are used to simulate, compute, or optimize the solution.\n\n### Differences:\n| Aspect | Algorithm Competitions | University Modeling Competitions |\n|--------|------------------------|----------------------------------|\n| Focus  | Efficiency, correctness, speed | Accuracy, realism, scalability |\n| Tools Used | Code (C++, Python, etc.) | Simulation tools, statistics, sometimes code |\n| Output | Program solving a specific task | Report + possibly simulation/model |\n| Timeframe | Short (hours) | Long (days or weeks) |\n\nIn summary, the process of **modeling** in both settings shares a common foundation: identifying the right abstractions and formalizing them to enable effective computation or analysis."}],"tags":["algorithm","thought-process","model","simulation"]},"__N_SSG":true}