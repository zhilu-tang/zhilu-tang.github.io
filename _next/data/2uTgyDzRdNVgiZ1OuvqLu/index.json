{"pageProps":{"postsMetaData":[{"metadata":{"title":"Perception On Tree Traversal","description":"Key perceptions about efficient tree traversal","imgName":"perception-on-tree-traversal/perception-on-tree-traversal.png","date":"Jul 30, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"xor-link-tree-and-leaf-peeling"},"content":"![Perception On Tree Traversal](perception-on-tree-traversal/perception-on-tree-traversal.png)\n \n###### Published on: **Jul 30, 2025**\n\n## Case Study: perception on the following implementation\nproblem id : maximize-the-number-of-target-nodes-after-connecting-trees-ii\n```java\nclass Solution {\n    public int[] maxTargetNodes(int[][] edges1, int[][] edges2) {\n        final int[] targets1 = computeTargets(edges1);\n        final int offset = findMax(computeTargets(edges2));\n        for (int i = 0; i < targets1.length; i++) {\n            targets1[i] += offset;\n        }\n        return targets1;\n    }\n\n    static final int findMax(int[] values) {\n        int maximum = 0;\n        for (int val : values) {\n            maximum = Math.max(maximum, val);\n        }\n        return maximum;\n    }\n\n    static int[] computeTargets(int[][] connections) {\n        final int nodeCount = connections.length + 1;\n        final int[] edgeCount = new int[nodeCount];\n        final int[] xorLink = new int[nodeCount];\n        final int[] result = new int[nodeCount];\n        Arrays.fill(result, 1);\n        final int[] stack = new int[nodeCount];\n\n        for (int[] pair : connections) {\n            final int u = pair[0];\n            final int v = pair[1];\n            edgeCount[u]++;\n            edgeCount[v]++;\n            xorLink[u] ^= v;\n            xorLink[v] ^= u;\n        }\n\n        int stackLength = 0;\n        for (int i = 0; i < nodeCount; i++) {\n            if (edgeCount[i] == 1) {\n                stack[stackLength++] = i;\n            }\n        }\n\n        for (int i = 0; i < connections.length; i++) {\n            final int current = stack[i];\n            final int parent = xorLink[current];\n            xorLink[parent] ^= current;\n            result[parent] -= result[current];\n            if (--edgeCount[parent] == 1) {\n                stack[stackLength++] = parent;\n            }\n        }\n\n        final int central = stack[nodeCount - 1];\n        result[central] = (nodeCount + result[central]) / 2;\n\n        for (int i = nodeCount - 2; i >= 0; i--) {\n            final int current = stack[i];\n            result[current] = nodeCount - result[xorLink[current]];\n        }\n\n        return result;\n    }\n}\n```\nThe XOR-linked tree representation is a space-efficient technique for representing trees. Here are the core insights:\n\n## Key Insights of XOR-Linked Tree Representation\n\n### 1. **Space Efficiency**\n- Instead of storing adjacency lists or matrices, only two arrays are needed:\n  - `xorLink[]`: Stores XOR of all neighbors for each node\n  - `edgeCount[]`: Stores degree of each node\n- Space complexity: O(n) instead of O(n + m) for adjacency list\n\n### 2. **XOR Properties for Tree Traversal**\n```text\nIf node A is connected to nodes B, C, D:\nxorLink[A] = B âŠ• C âŠ• D\n\nTo find a specific neighbor (e.g., B), if you know the others:\nB = xorLink[A] âŠ• C âŠ• D\n```\n\n### 3. **Leaf Peeling Algorithm Core Insight**\n- Start with leaves (nodes with degree 1)\n- Process nodes in leaf-to-root order\n- When removing a leaf, update its parent's information\n\n### 4. **Key Operations**\n\n```java\n// Building XOR links\nfor (int[] pair : connections) {\n    xorLink[u] ^= v;  // Add v to u's neighbor list\n    xorLink[v] ^= u;  // Add u to v's neighbor list\n}\n\n// Finding parent of a leaf node\nint parent = xorLink[leaf];  // Works because leaf has only one neighbor\n\n// Removing leaf from parent\nxorLink[parent] ^= leaf;     // Remove leaf from parent's neighbor list\n```\n\n## Algorithm Core Insight\n\nThe traversal algorithm uses a **topological processing approach**:\n\n1. **Leaf Queue Construction**: Identify all initial leaves (degree = 1)\n2. **Leaf Processing**: Process leaves in FIFO order\n3. **Tree Shrinking**: When a leaf is processed, its parent may become a new leaf\n4. **Information Propagation**: Maintain subtree size relationships during processing\n\n## Mathematical Insight\n\nThe key mathematical insight for computing targets:\n- For any node, targets = nodes reachable via even-length paths\n- This equals: `(total_nodes + subtree_size) / 2` for the root\n- For other nodes: if we know parent's target count, child's = `total - parent_target`\n\nThis representation is particularly elegant because:\n1. It eliminates the need for complex graph data structures\n2. It enables purely arithmetic operations for traversal\n3. It naturally supports the leaf-peeling algorithm\n4. It's cache-friendly with sequential memory access patterns"},{"metadata":{"title":"Perception On Gray Code Subset Traversal","description":"Key perceptions about gray code subset traversal","imgName":"on-gray-code-subset-traversal/on-gray-code-subset-traversal.png","date":"Jul 25, 2025","tags":["model","algorithm","template"],"keywords":["algorithm","perception","math"],"id":"on-gray-code-subset-traversal"},"content":"![Perception On Gray Code Subset Traversal](on-gray-code-subset-traversal/on-gray-code-subset-traversal.png)\n \n###### Published on: **Jul 25, 2025**\n\n# Gray Code Subset Traversal Template and DP State Analysis\n\n## Java Template for Gray Code Subset Traversal\n\n```java\n// Template 1: Standard Gray Code Subset Sum Generation\npublic int[] generateSubsetSums(int[] nums) {\n    int n = nums.length;\n    int[] sums = new int[1 << n];\n    \n    for (int i = 1; i < (1 << n); i++) {\n        // Key bit operations:\n        // i & (i - 1): removes the lowest set bit\n        // Integer.numberOfTrailingZeros(i): gets index of lowest set bit\n        sums[i] = sums[i & (i - 1)] + nums[Integer.numberOfTrailingZeros(i)];\n    }\n    \n    return sums;\n}\n\n// Template 2: Generic Subset Processing with Gray Code\npublic void processSubsets(int[] nums) {\n    int n = nums.length;\n    \n    // Process empty subset\n    processSubset(new ArrayList<>(), 0);\n    \n    for (int mask = 1; mask < (1 << n); mask++) {\n        int prevMask = mask & (mask - 1);\n        int addedIndex = Integer.numberOfTrailingZeros(mask);\n        \n        // Build current subset based on previous computation\n        // This is the DP transition\n        processSubset(buildFromPrevious(prevMask, addedIndex), mask);\n    }\n}\n\n// Template 3: Iterative Subset with State Maintenance\npublic void subsetDP(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[1 << n]; // dp[mask] = some computed value for subset represented by mask\n    \n    for (int mask = 1; mask < (1 << n); mask++) {\n        int prev = mask & (mask - 1);           // Previous state\n        int bitIndex = Integer.numberOfTrailingZeros(mask);  // Element being added\n        \n        // DP Transition: combine previous state with new element\n        dp[mask] = transitionFunction(dp[prev], nums[bitIndex]);\n    }\n}\n```\n\n## DP State Analysis\n\n### State Definition\n- **State**: `dp[mask]` represents the computed value for the subset indicated by the bitmask\n- **Mask Representation**: Each bit in the mask corresponds to whether an element is included (1) or excluded (0)\n\n### State Transition\n\n```text\nFor mask from 1 to 2^n - 1:\n    prev_mask = mask & (mask - 1)     // Remove lowest set bit\n    added_element_index = numberOfTrailingZeros(mask)\n    \n    dp[mask] = combine(dp[prev_mask], element[added_element_index])\n```\n\n### Key Bit Operations Explanation\n\n1. **`mask & (mask - 1)`**\n   - Removes the lowest set bit from mask\n   - Example: `1100 & 1011 = 1000` (removes rightmost 1)\n   - This gives us the \"previous\" subset in Gray code sequence\n\n2. **`Integer.numberOfTrailingZeros(mask)`**\n   - Counts number of trailing zeros in binary representation\n   - Gives index of the lowest set bit\n   - Example: `1100` â†’ 2 trailing zeros â†’ element at index 2 was added\n\n### Transition Examples\n\n```java\n// Example 1: Subset Sum\ndp[mask] = dp[mask & (mask - 1)] + nums[Integer.numberOfTrailingZeros(mask)];\n\n// Example 2: Subset Product  \ndp[mask] = dp[mask & (mask - 1)] * nums[Integer.numberOfTrailingZeros(mask)];\n\n// Example 3: Subset with Additional State\n// dp[mask][parity] = value considering parity of subset size\nint prev = mask & (mask - 1);\nint idx = Integer.numberOfTrailingZeros(mask);\ndp[mask][0] = dp[prev][1] + nums[idx];  // Even size subset\ndp[mask][1] = dp[prev][0] + nums[idx];  // Odd size subset\n```\n\n## Complexity Analysis\n\n- **Time**: O(2^n) - visits each subset exactly once\n- **Space**: O(2^n) - stores value for each subset\n- **Advantage**: No recursion overhead, cache-friendly iteration\n\n## Key Insights\n\n1. **Gray Code Property**: Each iteration differs from previous by exactly one element\n2. **DP Efficiency**: Leverages previously computed results to build current state\n3. **Bit Manipulation**: Elegant way to enumerate and relate subsets\n4. **Memory Locality**: Sequential access pattern improves cache performance\n\nThis approach is particularly powerful for subset problems where the solution for a subset can be efficiently computed from a \"nearby\" subset that differs by one element."},{"metadata":{"title":"Perception On Rolling Hash","description":"Key perceptions about Rolling Hash for Strings, pitfalls, and best practices","imgName":"perception-on-rolling-hash/perception-on-rolling-hash.png","date":"Jul 24, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"on-rolling-hash"},"content":"![Perception On Rolling Hash](perception-on-rolling-hash/perception-on-rolling-hash.png)\n \n###### Published on: **Jul 24, 2025**\n\n## ğŸ”‘ Key Insights about Rolling Hash for Strings\n\nRolling hash is a powerful technique for string processing that allows efficient computation and comparison of substring hashes. Here are the essential insights:\n\n### 1. **Core Principle**\n- Compute hash values for substrings using polynomial hashing\n- Formula: `hash(s[0...n-1]) = s[0]*p^(n-1) + s[1]*p^(n-2) + ... + s[n-1]*p^0`\n- Enable O(1) computation of any substring hash from precomputed prefix hashes\n\n### 2. **Rolling Property**\n- Given hash of substring `s[i...j]`, can compute hash of `s[i+1...j+1]` in O(1)\n- This property makes it ideal for sliding window algorithms\n\n### 3. **Preprocessing Advantage**\n- Compute all prefix hashes in O(n) time\n- Any substring hash can be computed in O(1) time afterward\n\n## âš ï¸ Key Problems and Collision Issues\n\n### 1. **Hash Collisions**\n```java\n// Example of collision (simplified)\n// Two different strings might have same hash value\nString s1 = \"abc\", s2 = \"def\";\n// With certain BASE/MOD, hash(s1) might equal hash(s2)\n```\n\n### 2. **Modulo Arithmetic Limitations**\n- Using finite MOD space means collisions are inevitable\n- Birthday paradox: collisions occur more frequently than expected\n\n### 3. **Poor Parameter Choices**\n- Small BASE or MOD values increase collision probability\n- Powers of 2 as BASE can lead to poor distribution\n\n## ğŸ›¡ï¸ Mitigation Strategies\n\n### 1. **Double Hashing**\n```java\nclass DoubleHash {\n    private static final long BASE1 = 31, BASE2 = 37;\n    private static final long MOD1 = 1000000007, MOD2 = 1000000009;\n    \n    // Use pair of hashes to reduce collision probability\n    long hash1, hash2;\n    \n    // Compare both hash values for equality\n    public boolean equals(Object other) {\n        DoubleHash o = (DoubleHash) other;\n        return hash1 == o.hash1 && hash2 == o.hash2;\n    }\n}\n```\n\n### 2. **Large Prime Parameters**\n- Use large primes for MOD (e.g., 10^9+7, 10^9+9)\n- Choose BASE that's relatively prime to MOD\n- Avoid powers of 2 or small primes for BASE\n\n### 3. **Verification for Critical Applications**\n```java\n// When hash matches, verify actual string equality if correctness is critical\nif (hash1 == hash2) {\n    // Only do expensive string comparison when hashes match\n    if (actualStringComparison(str1, str2)) {\n        // Truly equal\n    }\n}\n```\n\n### 4. **Good Parameter Selection**\n- BASE: Use prime numbers (commonly 31, 37, 41, 43)\n- MOD: Use large primes (10^9+7, 10^9+9, or even larger)\n- Avoid BASE=2, 10 which have poor distribution properties\n\n## ğŸ¯ When to Use Rolling Hash\n\n### âœ… Good Use Cases:\n- String matching algorithms (Rabin-Karp)\n- Finding duplicate substrings\n- Palindrome detection\n- Counting distinct substrings\n- When approximate equality is acceptable\n\n### âŒ Avoid When:\n- Cryptographic security is required\n- Exact string matching is critical without verification\n- Very small strings where overhead doesn't pay off\n\n## ğŸ’¡ Best Practices\n\n### 1. **Always Consider Collision Probability**\n- For n strings, collision probability is roughly nÂ²/(2*MOD)\n- Choose MOD appropriately for your data size\n\n### 2. **Precompute Powers**\n```java\n// Precompute powers of BASE to avoid repeated calculations\nlong[] powers = new long[n];\npowers[0] = 1;\nfor (int i = 1; i < n; i++) {\n    powers[i] = (powers[i-1] * BASE) % MOD;\n}\n```\n\n### 3. **Handle Negative Results**\n```java\n// Always ensure hash values are positive\nlong hash = (computed_hash % MOD + MOD) % MOD;\n```\n\n### 4. **Memory vs Time Tradeoff**\n- Decide whether to precompute all substring hashes or compute on demand\n- Consider the specific problem constraints\n\nRolling hash is a powerful tool when used correctly, but requires careful consideration of parameters and collision handling to ensure reliable results."},{"metadata":{"title":"Daily Thought Fallacies","description":"A case study about a trapped thought process.","imgName":"daily-thought-fallacies/daily-thought-fallacies.png","date":"Jul 1, 2025","tags":["algorithm","thought-process"],"keywords":["trap","algorithm","thought"],"id":"daily-thought-fallacies"},"content":"![Daily thought fallacies](daily-thought-fallacies/daily-thought-fallacies.png)\n \n###### Published on: **Jul 1, 2025**\n\n## é—®é¢˜\n### è¯„ä»·ä¸‹é¢ä»£ç çš„æ•´ä½“æ€è·¯ã€å…³é”®å®ç°å¯¹é”™\n```java\n    static int[][] fh;\n    public int trapRainWaterWA2(int[][] heightMap) {\n        fh = heightMap;\n        int m = heightMap.length, n = heightMap[0].length;\n        int dir[] = {1,0,-1,0,1};\n        int ans = 0;\n        record Cell(int i, int j) implements Comparable<Cell>{\n            public int compareTo(Cell o){\n                return fh[i][j] - fh[o.i][o.j];\n            }\n        }\n        PriorityQueue<Cell> pq = new PriorityQueue<Cell>();\n        boolean used[][] = new boolean[m][n], visited[][];\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(!used[i][j]){\n                    pq.clear();\n                    visited = new boolean[m][n];\n                    // start\n                    var start = new Cell(i,j);\n                    pq.offer(start);\n                    visited[i][j] = true;\n                    used[i][j] = true;\n                    int bottom = heightMap[i][j], count = 0;\n                    while(!pq.isEmpty()){\n                        var c = pq.poll();\n                        int curh = heightMap[c.i][c.j];\n                        if(curh > bottom){\n                            ans += (curh - bottom) * count;\n                            bottom = curh;\n                        }\n                        if(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1)break;\n                        if(!used[c.i][c.j]){\n                            count++;\n                        }\n                        used[c.i][c.j] = true;\n                        for(int d = 0; d<4; d++){\n                            int x = c.i+dir[d], y = c.j+dir[d+1];\n                            if(x < 0 || y < 0 || x >= m || y >= n || visited[x][y])continue;\n                            visited[x][y] = true;\n                            pq.offer(new Cell(x, y));\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n```\n## è§£ç­”\nThe code attempts to solve the **Trapping Rain Water II** problem, where water can be trapped in a 2D elevation map. However, the implementation contains several **logical and structural errors**, which prevent it from working correctly.\n\n---\n\n### âœ… Overall Idea\n\nThe idea is based on using a **priority queue (min-heap)** to simulate the process of water flowing from the boundary inward, similar to Dijkstra's algorithm:\n\n- Start from the **border cells** as boundaries cannot trap water.\n- Use a **min-heap** to always process the lowest height cell next.\n- As you expand inward, any lower area surrounded by higher walls can potentially trap water.\n\nThis is a valid approach for this problem.\n\n---\n\n### âŒ Key Implementation Errors\n\n#### 1. **Incorrect BFS/Heap Usage**\n```java\nif(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1) break;\n```\n- This line breaks the search when reaching any border cell.\n- **Problem**: The algorithm should start from the borders and explore inward. Instead, it stops as soon as it reaches a border, effectively ignoring the correct flow logic.\n\n#### 2. **Misuse of `used` and `visited`**\n- `used` seems to mark whether a cell has been processed globally, while `visited` is reinitialized in each loop.\n- **Problem**: The inner BFS (`pq`) is not tracking global visited status properly, leading to:\n  - Re-processing of already visited regions.\n  - Incomplete traversal.\n\n#### 3. **Wrong Calculation of Trapped Water**\n```java\nif(!used[c.i][c.j]){\n    count++;\n}\n```\n- `count` is used to track how many cells are in the current basin.\n- **Problem**: It doesn't account for the actual volume of water trapped per unit height difference correctly.\n- Also, `used[i][j] = true;` is set after checking, which may cause incorrect counting.\n\n#### 4. **Use of Local Class Inside Method (Java 16+ only)**\n```java\nrecord Cell(int i, int j) implements Comparable<Cell>\n```\n- **Issue**: This uses a local record inside a method, which is only supported in Java 16+. If the environment supports it, that's fine, but if not, it will fail to compile.\n\nAlso, the `compareTo` method uses `fh[i][j]`, but `fh` is a class-level variable (`this.fh`). This could lead to confusion or bugs if `fh` changes during execution.\n\n#### 5. **Redundant Outer Loop**\n- The outer double loop over all `(i,j)` is unnecessary.\n- **Correct approach**: Initialize the heap with all border cells first, then expand inward â€” no need to re-start BFS from every unvisited cell.\n\n---\n\n### ğŸ› ï¸ Suggested Fixes\n\n#### âœ”ï¸ Corrected Algorithm Outline\n\n1. **Initialize a min-heap** with all the border cells.\n2. Maintain a global `visited` matrix.\n3. While the heap is not empty:\n   - Pop the lowest cell.\n   - For its four neighbors:\n     - If not visited:\n       - If neighbor is lower than current height, it can trap water.\n       - Add neighbor to the heap with its own height.\n4. Accumulate trapped water accordingly.\n\n#### âœ”ï¸ Code Skeleton Fix\n\n```java\npublic int trapRainWater(int[][] heightMap) {\n    if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)\n        return 0;\n\n    int m = heightMap.length, n = heightMap[0].length;\n    boolean[][] visited = new boolean[m][n];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // x, y, height\n    int[] dirs = {0, 1, 0, -1, 0};\n\n    // Initialize with boundary cells\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n                pq.offer(new int[]{i, j, heightMap[i][j]});\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    int res = 0;\n    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int maxHeight = 0;\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int x = curr[0], y = curr[1], h = curr[2];\n        maxHeight = Math.max(maxHeight, h);\n\n        for (int[] dir : directions) {\n            int nx = x + dir[0], ny = y + dir[1];\n            if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                if (heightMap[nx][ny] < maxHeight) {\n                    res += maxHeight - heightMap[nx][ny];\n                }\n                pq.offer(new int[]{nx, ny, Math.max(maxHeight, heightMap[nx][ny])});\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n---\n\n### âœ… Summary\n\n| Aspect | Evaluation |\n|-------|------------|\n| **Algorithm Design** | Partially correct conceptually, but flawed in implementation |\n| **Data Structures** | Priority Queue used incorrectly |\n| **Visited Tracking** | Confusing and incorrect |\n| **Water Calculation** | Incorrect logic |\n| **Code Structure** | Poor modularity and readability |\n\n---\n\n### ğŸ“Œ Conclusion\n\nWhile the general idea of using a priority queue to simulate water flow is sound, the current implementation fails due to incorrect handling of visited nodes, early termination, and wrong calculation of trapped water. A revised version using a proper BFS-like approach with a min-heap and global visited tracking is necessary for correctness.\n\n## é—®é¢˜\nè¿™ç§æ€ç»´æ¨¡å¼è¸©ä¸­äº†å“ªä¸ªè¯¯åŒºï¼Ÿè¯•ç€ä»æ›´é«˜ç»´åº¦åˆ†è§£è¿™ç§æ€ç»´æ¨¡å¼çš„é—®é¢˜ã€‚ï¼ˆèƒ½å¤Ÿç†è§£æ­£ç¡®çš„åšæ³•æ˜¯ç®€æ´çš„ï¼Œæ¨¡æ‹Ÿæ°´ä½ä¸Šæ¶¨é€æ¸æ·¹æ²¡æ‰€æœ‰ä½ç½®ï¼Œç¬¬ä¸€æ¬¡æ·¹æ²¡æ—¶çš„é«˜å·®ï¼Œå°±æ˜¯ trap çš„æ°´ä½“ç§¯ï¼Œæ­£ç¡®çš„åšæ³•è¶³å¤Ÿç®€æ´æ¸…æ™°ï¼‰ã€‚\nThis code's thought process falls into a **\"å±€éƒ¨è´ªå¿ƒ + å¤šé‡åµŒå¥—çŠ¶æ€\"** thinking trap. It attempts to simulate the water trapping process by treating each basin separately and trying to compute local trapped water using nested loops and conditions.\n\n---\n\n### ğŸ§  é«˜ç»´æ€ç»´æ¨¡å¼åˆ†æï¼ˆHigher-Level Pattern Analysisï¼‰\n\n#### 1. **è¯¯åŒºåç§°ï¼šå±€éƒ¨æ¨¡æ‹Ÿé™·é˜± / åˆ†æ²»å¼æš´åŠ›ï¼ˆLocal Simulation Fallacyï¼‰**\n\nThe developer tried to simulate water filling **locally**, assuming that each \"valley\" or enclosed area can be processed independently, starting from any unvisited cell.\n\n##### ğŸ” ç‰¹å¾ï¼š\n- ä½¿ç”¨ `for` å¾ªç¯ä»æ¯ä¸ªæœªè®¿é—®çš„ç‚¹å‡ºå‘ï¼Œå°è¯•â€œç‹¬ç«‹â€å¤„ç†ã€‚\n- æ¯æ¬¡ BFS éƒ½è¯•å›¾è®¡ç®—å½“å‰åŒºåŸŸçš„ç§¯æ°´ä½“ç§¯ã€‚\n- æ²¡æœ‰ç»Ÿä¸€æ°´ä½ä¸Šæ¶¨æ¨¡å‹ï¼Œè€Œæ˜¯åˆ†å—å¤„ç†ã€‚\n\n##### âŒ é—®é¢˜æœ¬è´¨ï¼š\n- å¿½è§†äº†å…¨å±€æ°´ä½é€æ¸ä¸Šå‡è¿™ä¸€ç‰©ç†è¿‡ç¨‹ã€‚\n- æŠŠé—®é¢˜æ‹†è§£ä¸ºå¤šä¸ªå­é—®é¢˜ï¼Œåè€Œå¼•å…¥å¤æ‚è¾¹ç•Œæ¡ä»¶å’Œé‡å¤è®¡ç®—ã€‚\n- ç”¨ `used[][]` å’Œ `visited[][]` æ¥é˜²æ­¢é‡å¤è®¿é—®ï¼Œä½†é€»è¾‘æ··ä¹±å¯¼è‡´é”™è¯¯ã€‚\n\n---\n\n#### 2. **è®¤çŸ¥ç»´åº¦ï¼šæ²¡æœ‰æŠ½è±¡å‡ºæ ¸å¿ƒå˜é‡ï¼ˆFailure to Abstract Core Variablesï¼‰**\n\næ­£ç¡®çš„åšæ³•ä¸­ï¼Œ**maxHeight** æ˜¯ä¸€ä¸ªæ ¸å¿ƒæŠ½è±¡å˜é‡ï¼Œå®ƒä»£è¡¨å½“å‰çš„â€œæ°´ä½çº¿â€ã€‚\n\n##### âœ… æ­£ç¡®è§†è§’ï¼š\n- æ‰€æœ‰ç§¯æ°´éƒ½å‘ç”Ÿåœ¨æŸä¸€ç‚¹ä½äºå½“å‰æ°´ä½æ—¶ã€‚\n- æ°´ä½æ˜¯å•è°ƒä¸é™çš„ï¼Œéšç€ä¼˜å…ˆé˜Ÿåˆ—å¼¹å‡ºæœ€å°é«˜åº¦è€Œé€æ­¥å‡é«˜ã€‚\n- æ¯ä¸ªç‚¹åªè¢«è®¿é—®ä¸€æ¬¡ï¼Œé¿å…é‡å¤åˆ¤æ–­å’Œé”™è¯¯ç§¯ç´¯ã€‚\n\n##### âŒ é”™è¯¯è§†è§’ï¼š\n- æ²¡æœ‰å»ºç«‹â€œå…¨å±€æ°´ä½â€çš„æŠ½è±¡ï¼Œè€Œæ˜¯ä¾èµ–å±€éƒ¨æ¯”è¾ƒï¼ˆå¦‚ `curh > bottom`ï¼‰ã€‚\n- å°† `bottom` å½“ä½œæŸç§åŸºå‡†é«˜åº¦ï¼Œä½†å®é™…ä¸Šå®ƒä¸å…·å¤‡å…¨å±€ä¸€è‡´æ€§ã€‚\n- æ²¡æœ‰æ„è¯†åˆ°â€œç¬¬ä¸€æ¬¡æ·¹æ²¡â€è¿™ä¸ªå…³é”®äº‹ä»¶çš„ä»·å€¼ã€‚\n\n---\n\n#### 3. **ç®—æ³•è®¾è®¡è¯¯åŒºï¼šå¿½è§†æœ€ä¼˜å­ç»“æ„ï¼ˆIgnoring Optimal Substructureï¼‰**\n\nè¿™é“é¢˜å…·æœ‰å…¸å‹çš„**æœ€çŸ­è·¯å¾„/æœ€å°å †æ‰©å±•**æ€§è´¨ï¼š\n\n##### âœ… æ­£ç¡®æ–¹æ³•çš„æœ¬è´¨ï¼š\n- åˆ©ç”¨æœ€å°å †ç»´æŠ¤å½“å‰æœ€ä½è¾¹ç•Œã€‚\n- æ¯æ¬¡æ‰©å±•æœ€ä½ç‚¹ï¼Œç¡®ä¿å½“å‰æ°´ä½æ˜¯æœ€å°å¯æ·¹æ²¡é«˜åº¦ã€‚\n- ç±»ä¼¼äº Dijkstra ç®—æ³•ä¸­çš„æ¾å¼›æ“ä½œã€‚\n\n##### âŒ é”™è¯¯æ–¹æ³•çš„é—®é¢˜ï¼š\n- æ²¡æœ‰åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„â€œæœ€å°é«˜åº¦ä¼˜å…ˆâ€ç‰¹æ€§æ¥é©±åŠ¨æ•´ä¸ªæœç´¢æµç¨‹ã€‚\n- æ··åˆä½¿ç”¨äº† BFSã€DFS å’Œè´ªå¿ƒç­–ç•¥ï¼Œå¯¼è‡´çŠ¶æ€å¤±æ§ã€‚\n\n---\n\n### ğŸ§© æ€ç»´æ¨¡å¼é«˜ç»´åˆ†è§£å›¾\n\n| ç»´åº¦ | é”™è¯¯æ¨¡å¼ | æ­£ç¡®æ¨¡å¼ |\n|------|----------|-----------|\n| **æŠ½è±¡å±‚çº§** | å±€éƒ¨æ¨¡æ‹Ÿï¼Œç¼ºä¹ç»Ÿä¸€æ°´ä½æŠ½è±¡ | å…¨å±€æ°´ä½ä¸Šæ¶¨æ¨¡å‹ |\n| **æ§åˆ¶æµç»“æ„** | å¤šå±‚åµŒå¥—å¾ªç¯ + å¤šé‡æ¡ä»¶åˆ†æ”¯ | å•ä¸€ä¼˜å…ˆé˜Ÿåˆ—é©±åŠ¨æµç¨‹ |\n| **æ•°æ®ç»“æ„ä½¿ç”¨** | å †ä»…ç”¨äºå±€éƒ¨æœç´¢ | å †é©±åŠ¨å…¨å±€æ‰©å±•é¡ºåº |\n| **è®¿é—®æœºåˆ¶** | åŒé‡ visited æ§åˆ¶ï¼Œé€»è¾‘æ··ä¹± | å•ä¸€ visited + æœ€æ—©è®¿é—®å³æœ€æ—©æ·¹æ²¡ |\n| **é—®é¢˜å»ºæ¨¡æ–¹å¼** | åˆ†æ²»å¤„ç†æ¯ä¸ªâ€œå‘â€ | æ•´ä½“åœ°å½¢æ´ªæ°´æ¨¡æ‹Ÿ |\n\n---\n\n### ğŸ§­ è®¤çŸ¥å‡çº§å»ºè®®\n\nè¦è·³å‡ºè¿™ç±»æ€ç»´è¯¯åŒºï¼Œå¯ä»¥å°è¯•ä»¥ä¸‹æ€ç»´æ–¹å¼ï¼š\n\n#### âœ… 1. **å¯»æ‰¾æ ¸å¿ƒæŠ½è±¡å˜é‡**\n- åœ¨æœ¬é¢˜ä¸­ï¼Œâ€œå½“å‰æ°´ä½â€å°±æ˜¯å”¯ä¸€é‡è¦çš„å˜é‡ã€‚\n- æ‰€æœ‰æ“ä½œéƒ½åº”è¯¥å›´ç»•å®ƒè¿›è¡Œæ›´æ–°å’Œæ¯”è¾ƒã€‚\n\n#### âœ… 2. **ç”¨ç‰©ç†è¿‡ç¨‹ç±»æ¯”ç®—æ³•è¡Œä¸º**\n- æƒ³è±¡çœŸå®çš„æ°´æ…¢æ…¢ä¸Šæ¶¨çš„è¿‡ç¨‹ã€‚\n- è¿™æ ·èƒ½è‡ªç„¶å¼•å¯¼å‡ºä¼˜å…ˆé˜Ÿåˆ—å’Œæ°´ä½é€’å¢çš„æ€è·¯ã€‚\n\n#### âœ… 3. **è¿½æ±‚â€œäº‹ä»¶é©±åŠ¨â€çš„ç¼–ç¨‹æ€æƒ³**\n- æ¯ä¸ªç‚¹è¢«è®¿é—®æ—¶æ˜¯ä¸€ä¸ªâ€œäº‹ä»¶â€ï¼Œè§¦å‘æ°´ä½æ›´æ–°ã€‚\n- è€Œä¸æ˜¯ç”¨å¾ªç¯å»â€œå¼ºè¡Œâ€éå†æ‰€æœ‰å¯èƒ½ã€‚\n\n#### âœ… 4. **ç®€åŒ–é—®é¢˜è€Œéå¤æ‚åŒ–å¤„ç†**\n- ä¸è¦è¯•å›¾åœ¨ä»£ç é‡Œè§£å†³æ‰€æœ‰è¾¹ç•Œæƒ…å†µã€‚\n- å¦‚æœä¸€ä¸ªé—®é¢˜çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œé‚£å¯èƒ½æ˜¯å»ºæ¨¡æ–¹å¼é”™äº†ã€‚\n\n---\n\n### ğŸ¯ ç»“è¯­\n\nè¿™æ®µä»£ç æœ¬è´¨ä¸Šè¸©è¿›äº†â€œ**å¾®è§‚æ¨¡æ‹Ÿé™·é˜±**â€ï¼šè¯•å›¾ä»ç»†èŠ‚ä¸Šè¿˜åŸæ¯ä¸€ä¸ªç§¯æ°´åœºæ™¯ï¼Œå´å¿½ç•¥äº†æ•´ä½“ç³»ç»Ÿçš„è¡Œä¸ºè§„å¾‹ã€‚çœŸæ­£çš„é«˜æ•ˆè§£æ³•å¾€å¾€æ¥æºäºå¯¹ç³»ç»Ÿå®è§‚è¡Œä¸ºçš„ç†è§£ä¸å»ºæ¨¡ã€‚\n\nâ€œèªæ˜çš„ç®—æ³•ä¸åœ¨äºå†™å¾—å¤šå¤æ‚ï¼Œè€Œåœ¨äºæŠ“ä½é‚£ä¸ªæœ€ç®€å•çš„ç‰©ç†è§„åˆ™ã€‚â€"},{"metadata":{"title":"The Core Lies In Modeling","description":"Comparison of computer algorithm competitions and university-level mathematical or simulation modeling competitions","imgName":"modeling-as-a-core/modeling-as-a-core.png","date":"Jul 1, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","modeling","math"],"id":"modeling-as-a-core"},"content":"![The Core Lies In Modeling](modeling-as-a-core/modeling-as-a-core.png)\n \n###### Published on: **Jul 1, 2025**\n\nYes, the \"modeling\" in both computer algorithm competitions and university-level mathematical or simulation modeling competitions follows similar principles, though they differ in focus and application domains.\n\n### Key Similarities:\n1. **Problem Abstraction**:\n   - In both cases, the core lies in abstracting a real-world or problem scenario into a simplified **model**, which could be represented by variables, relationships, constraints, or rules.\n   \n2. **Use of Variables and Relationships**:\n   - In programming contests, you often define key variables (e.g., `dp[i][j]` for dynamic programming) to capture states.\n   - In university modeling contests, you similarly define variables (e.g., `x(t)` for time-dependent systems) and relationships (e.g., differential equations, statistical models).\n\n3. **Mathematical or Logical Formulation**:\n   - Both require translating the problem into a precise formulationâ€”be it an algorithmic model, a mathematical equation system, or a graph structure.\n\n4. **Computational Tools/Data Structures**:\n   - After building the model, appropriate data structures (like trees, graphs, arrays) or computational tools (like MATLAB, Python, or optimization libraries) are used to simulate, compute, or optimize the solution.\n\n### Differences:\n| Aspect | Algorithm Competitions | University Modeling Competitions |\n|--------|------------------------|----------------------------------|\n| Focus  | Efficiency, correctness, speed | Accuracy, realism, scalability |\n| Tools Used | Code (C++, Python, etc.) | Simulation tools, statistics, sometimes code |\n| Output | Program solving a specific task | Report + possibly simulation/model |\n| Timeframe | Short (hours) | Long (days or weeks) |\n\nIn summary, the process of **modeling** in both settings shares a common foundation: identifying the right abstractions and formalizing them to enable effective computation or analysis."}],"tags":["algorithm","thought-process","model","simulation","template"]},"__N_SSG":true}