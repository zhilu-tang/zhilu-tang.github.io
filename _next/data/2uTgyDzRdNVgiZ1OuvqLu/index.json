{"pageProps":{"postsMetaData":[{"metadata":{"title":"Perception On Tree Traversal","description":"Key perceptions about efficient tree traversal","imgName":"perception-on-tree-traversal/perception-on-tree-traversal.png","date":"Jul 30, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"xor-link-tree-and-leaf-peeling"},"content":"![Perception On Tree Traversal](perception-on-tree-traversal/perception-on-tree-traversal.png)\n \n###### Published on: **Jul 30, 2025**\n\n## Case Study: perception on the following implementation\nproblem id : maximize-the-number-of-target-nodes-after-connecting-trees-ii\n```java\nclass Solution {\n    public int[] maxTargetNodes(int[][] edges1, int[][] edges2) {\n        final int[] targets1 = computeTargets(edges1);\n        final int offset = findMax(computeTargets(edges2));\n        for (int i = 0; i < targets1.length; i++) {\n            targets1[i] += offset;\n        }\n        return targets1;\n    }\n\n    static final int findMax(int[] values) {\n        int maximum = 0;\n        for (int val : values) {\n            maximum = Math.max(maximum, val);\n        }\n        return maximum;\n    }\n\n    static int[] computeTargets(int[][] connections) {\n        final int nodeCount = connections.length + 1;\n        final int[] edgeCount = new int[nodeCount];\n        final int[] xorLink = new int[nodeCount];\n        final int[] result = new int[nodeCount];\n        Arrays.fill(result, 1);\n        final int[] stack = new int[nodeCount];\n\n        for (int[] pair : connections) {\n            final int u = pair[0];\n            final int v = pair[1];\n            edgeCount[u]++;\n            edgeCount[v]++;\n            xorLink[u] ^= v;\n            xorLink[v] ^= u;\n        }\n\n        int stackLength = 0;\n        for (int i = 0; i < nodeCount; i++) {\n            if (edgeCount[i] == 1) {\n                stack[stackLength++] = i;\n            }\n        }\n\n        for (int i = 0; i < connections.length; i++) {\n            final int current = stack[i];\n            final int parent = xorLink[current];\n            xorLink[parent] ^= current;\n            result[parent] -= result[current];\n            if (--edgeCount[parent] == 1) {\n                stack[stackLength++] = parent;\n            }\n        }\n\n        final int central = stack[nodeCount - 1];\n        result[central] = (nodeCount + result[central]) / 2;\n\n        for (int i = nodeCount - 2; i >= 0; i--) {\n            final int current = stack[i];\n            result[current] = nodeCount - result[xorLink[current]];\n        }\n\n        return result;\n    }\n}\n```\nThe XOR-linked tree representation is a space-efficient technique for representing trees. Here are the core insights:\n\n## Key Insights of XOR-Linked Tree Representation\n\n### 1. **Space Efficiency**\n- Instead of storing adjacency lists or matrices, only two arrays are needed:\n  - `xorLink[]`: Stores XOR of all neighbors for each node\n  - `edgeCount[]`: Stores degree of each node\n- Space complexity: O(n) instead of O(n + m) for adjacency list\n\n### 2. **XOR Properties for Tree Traversal**\n```text\nIf node A is connected to nodes B, C, D:\nxorLink[A] = B ⊕ C ⊕ D\n\nTo find a specific neighbor (e.g., B), if you know the others:\nB = xorLink[A] ⊕ C ⊕ D\n```\n\n### 3. **Leaf Peeling Algorithm Core Insight**\n- Start with leaves (nodes with degree 1)\n- Process nodes in leaf-to-root order\n- When removing a leaf, update its parent's information\n\n### 4. **Key Operations**\n\n```java\n// Building XOR links\nfor (int[] pair : connections) {\n    xorLink[u] ^= v;  // Add v to u's neighbor list\n    xorLink[v] ^= u;  // Add u to v's neighbor list\n}\n\n// Finding parent of a leaf node\nint parent = xorLink[leaf];  // Works because leaf has only one neighbor\n\n// Removing leaf from parent\nxorLink[parent] ^= leaf;     // Remove leaf from parent's neighbor list\n```\n\n## Algorithm Core Insight\n\nThe traversal algorithm uses a **topological processing approach**:\n\n1. **Leaf Queue Construction**: Identify all initial leaves (degree = 1)\n2. **Leaf Processing**: Process leaves in FIFO order\n3. **Tree Shrinking**: When a leaf is processed, its parent may become a new leaf\n4. **Information Propagation**: Maintain subtree size relationships during processing\n\n## Mathematical Insight\n\nThe key mathematical insight for computing targets:\n- For any node, targets = nodes reachable via even-length paths\n- This equals: `(total_nodes + subtree_size) / 2` for the root\n- For other nodes: if we know parent's target count, child's = `total - parent_target`\n\nThis representation is particularly elegant because:\n1. It eliminates the need for complex graph data structures\n2. It enables purely arithmetic operations for traversal\n3. It naturally supports the leaf-peeling algorithm\n4. It's cache-friendly with sequential memory access patterns"},{"metadata":{"title":"Perception On Gray Code Subset Traversal","description":"Key perceptions about gray code subset traversal","imgName":"on-gray-code-subset-traversal/on-gray-code-subset-traversal.png","date":"Jul 25, 2025","tags":["model","algorithm","template"],"keywords":["algorithm","perception","math"],"id":"on-gray-code-subset-traversal"},"content":"![Perception On Gray Code Subset Traversal](on-gray-code-subset-traversal/on-gray-code-subset-traversal.png)\n \n###### Published on: **Jul 25, 2025**\n\n# Gray Code Subset Traversal Template and DP State Analysis\n\n## Java Template for Gray Code Subset Traversal\n\n```java\n// Template 1: Standard Gray Code Subset Sum Generation\npublic int[] generateSubsetSums(int[] nums) {\n    int n = nums.length;\n    int[] sums = new int[1 << n];\n    \n    for (int i = 1; i < (1 << n); i++) {\n        // Key bit operations:\n        // i & (i - 1): removes the lowest set bit\n        // Integer.numberOfTrailingZeros(i): gets index of lowest set bit\n        sums[i] = sums[i & (i - 1)] + nums[Integer.numberOfTrailingZeros(i)];\n    }\n    \n    return sums;\n}\n\n// Template 2: Generic Subset Processing with Gray Code\npublic void processSubsets(int[] nums) {\n    int n = nums.length;\n    \n    // Process empty subset\n    processSubset(new ArrayList<>(), 0);\n    \n    for (int mask = 1; mask < (1 << n); mask++) {\n        int prevMask = mask & (mask - 1);\n        int addedIndex = Integer.numberOfTrailingZeros(mask);\n        \n        // Build current subset based on previous computation\n        // This is the DP transition\n        processSubset(buildFromPrevious(prevMask, addedIndex), mask);\n    }\n}\n\n// Template 3: Iterative Subset with State Maintenance\npublic void subsetDP(int[] nums) {\n    int n = nums.length;\n    int[] dp = new int[1 << n]; // dp[mask] = some computed value for subset represented by mask\n    \n    for (int mask = 1; mask < (1 << n); mask++) {\n        int prev = mask & (mask - 1);           // Previous state\n        int bitIndex = Integer.numberOfTrailingZeros(mask);  // Element being added\n        \n        // DP Transition: combine previous state with new element\n        dp[mask] = transitionFunction(dp[prev], nums[bitIndex]);\n    }\n}\n```\n\n## DP State Analysis\n\n### State Definition\n- **State**: `dp[mask]` represents the computed value for the subset indicated by the bitmask\n- **Mask Representation**: Each bit in the mask corresponds to whether an element is included (1) or excluded (0)\n\n### State Transition\n\n```text\nFor mask from 1 to 2^n - 1:\n    prev_mask = mask & (mask - 1)     // Remove lowest set bit\n    added_element_index = numberOfTrailingZeros(mask)\n    \n    dp[mask] = combine(dp[prev_mask], element[added_element_index])\n```\n\n### Key Bit Operations Explanation\n\n1. **`mask & (mask - 1)`**\n   - Removes the lowest set bit from mask\n   - Example: `1100 & 1011 = 1000` (removes rightmost 1)\n   - This gives us the \"previous\" subset in Gray code sequence\n\n2. **`Integer.numberOfTrailingZeros(mask)`**\n   - Counts number of trailing zeros in binary representation\n   - Gives index of the lowest set bit\n   - Example: `1100` → 2 trailing zeros → element at index 2 was added\n\n### Transition Examples\n\n```java\n// Example 1: Subset Sum\ndp[mask] = dp[mask & (mask - 1)] + nums[Integer.numberOfTrailingZeros(mask)];\n\n// Example 2: Subset Product  \ndp[mask] = dp[mask & (mask - 1)] * nums[Integer.numberOfTrailingZeros(mask)];\n\n// Example 3: Subset with Additional State\n// dp[mask][parity] = value considering parity of subset size\nint prev = mask & (mask - 1);\nint idx = Integer.numberOfTrailingZeros(mask);\ndp[mask][0] = dp[prev][1] + nums[idx];  // Even size subset\ndp[mask][1] = dp[prev][0] + nums[idx];  // Odd size subset\n```\n\n## Complexity Analysis\n\n- **Time**: O(2^n) - visits each subset exactly once\n- **Space**: O(2^n) - stores value for each subset\n- **Advantage**: No recursion overhead, cache-friendly iteration\n\n## Key Insights\n\n1. **Gray Code Property**: Each iteration differs from previous by exactly one element\n2. **DP Efficiency**: Leverages previously computed results to build current state\n3. **Bit Manipulation**: Elegant way to enumerate and relate subsets\n4. **Memory Locality**: Sequential access pattern improves cache performance\n\nThis approach is particularly powerful for subset problems where the solution for a subset can be efficiently computed from a \"nearby\" subset that differs by one element."},{"metadata":{"title":"Perception On Rolling Hash","description":"Key perceptions about Rolling Hash for Strings, pitfalls, and best practices","imgName":"perception-on-rolling-hash/perception-on-rolling-hash.png","date":"Jul 24, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"on-rolling-hash"},"content":"![Perception On Rolling Hash](perception-on-rolling-hash/perception-on-rolling-hash.png)\n \n###### Published on: **Jul 24, 2025**\n\n## 🔑 Key Insights about Rolling Hash for Strings\n\nRolling hash is a powerful technique for string processing that allows efficient computation and comparison of substring hashes. Here are the essential insights:\n\n### 1. **Core Principle**\n- Compute hash values for substrings using polynomial hashing\n- Formula: `hash(s[0...n-1]) = s[0]*p^(n-1) + s[1]*p^(n-2) + ... + s[n-1]*p^0`\n- Enable O(1) computation of any substring hash from precomputed prefix hashes\n\n### 2. **Rolling Property**\n- Given hash of substring `s[i...j]`, can compute hash of `s[i+1...j+1]` in O(1)\n- This property makes it ideal for sliding window algorithms\n\n### 3. **Preprocessing Advantage**\n- Compute all prefix hashes in O(n) time\n- Any substring hash can be computed in O(1) time afterward\n\n## ⚠️ Key Problems and Collision Issues\n\n### 1. **Hash Collisions**\n```java\n// Example of collision (simplified)\n// Two different strings might have same hash value\nString s1 = \"abc\", s2 = \"def\";\n// With certain BASE/MOD, hash(s1) might equal hash(s2)\n```\n\n### 2. **Modulo Arithmetic Limitations**\n- Using finite MOD space means collisions are inevitable\n- Birthday paradox: collisions occur more frequently than expected\n\n### 3. **Poor Parameter Choices**\n- Small BASE or MOD values increase collision probability\n- Powers of 2 as BASE can lead to poor distribution\n\n## 🛡️ Mitigation Strategies\n\n### 1. **Double Hashing**\n```java\nclass DoubleHash {\n    private static final long BASE1 = 31, BASE2 = 37;\n    private static final long MOD1 = 1000000007, MOD2 = 1000000009;\n    \n    // Use pair of hashes to reduce collision probability\n    long hash1, hash2;\n    \n    // Compare both hash values for equality\n    public boolean equals(Object other) {\n        DoubleHash o = (DoubleHash) other;\n        return hash1 == o.hash1 && hash2 == o.hash2;\n    }\n}\n```\n\n### 2. **Large Prime Parameters**\n- Use large primes for MOD (e.g., 10^9+7, 10^9+9)\n- Choose BASE that's relatively prime to MOD\n- Avoid powers of 2 or small primes for BASE\n\n### 3. **Verification for Critical Applications**\n```java\n// When hash matches, verify actual string equality if correctness is critical\nif (hash1 == hash2) {\n    // Only do expensive string comparison when hashes match\n    if (actualStringComparison(str1, str2)) {\n        // Truly equal\n    }\n}\n```\n\n### 4. **Good Parameter Selection**\n- BASE: Use prime numbers (commonly 31, 37, 41, 43)\n- MOD: Use large primes (10^9+7, 10^9+9, or even larger)\n- Avoid BASE=2, 10 which have poor distribution properties\n\n## 🎯 When to Use Rolling Hash\n\n### ✅ Good Use Cases:\n- String matching algorithms (Rabin-Karp)\n- Finding duplicate substrings\n- Palindrome detection\n- Counting distinct substrings\n- When approximate equality is acceptable\n\n### ❌ Avoid When:\n- Cryptographic security is required\n- Exact string matching is critical without verification\n- Very small strings where overhead doesn't pay off\n\n## 💡 Best Practices\n\n### 1. **Always Consider Collision Probability**\n- For n strings, collision probability is roughly n²/(2*MOD)\n- Choose MOD appropriately for your data size\n\n### 2. **Precompute Powers**\n```java\n// Precompute powers of BASE to avoid repeated calculations\nlong[] powers = new long[n];\npowers[0] = 1;\nfor (int i = 1; i < n; i++) {\n    powers[i] = (powers[i-1] * BASE) % MOD;\n}\n```\n\n### 3. **Handle Negative Results**\n```java\n// Always ensure hash values are positive\nlong hash = (computed_hash % MOD + MOD) % MOD;\n```\n\n### 4. **Memory vs Time Tradeoff**\n- Decide whether to precompute all substring hashes or compute on demand\n- Consider the specific problem constraints\n\nRolling hash is a powerful tool when used correctly, but requires careful consideration of parameters and collision handling to ensure reliable results."},{"metadata":{"title":"Daily Thought Fallacies","description":"A case study about a trapped thought process.","imgName":"daily-thought-fallacies/daily-thought-fallacies.png","date":"Jul 1, 2025","tags":["algorithm","thought-process"],"keywords":["trap","algorithm","thought"],"id":"daily-thought-fallacies"},"content":"![Daily thought fallacies](daily-thought-fallacies/daily-thought-fallacies.png)\n \n###### Published on: **Jul 1, 2025**\n\n## 问题\n### 评价下面代码的整体思路、关键实现对错\n```java\n    static int[][] fh;\n    public int trapRainWaterWA2(int[][] heightMap) {\n        fh = heightMap;\n        int m = heightMap.length, n = heightMap[0].length;\n        int dir[] = {1,0,-1,0,1};\n        int ans = 0;\n        record Cell(int i, int j) implements Comparable<Cell>{\n            public int compareTo(Cell o){\n                return fh[i][j] - fh[o.i][o.j];\n            }\n        }\n        PriorityQueue<Cell> pq = new PriorityQueue<Cell>();\n        boolean used[][] = new boolean[m][n], visited[][];\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(!used[i][j]){\n                    pq.clear();\n                    visited = new boolean[m][n];\n                    // start\n                    var start = new Cell(i,j);\n                    pq.offer(start);\n                    visited[i][j] = true;\n                    used[i][j] = true;\n                    int bottom = heightMap[i][j], count = 0;\n                    while(!pq.isEmpty()){\n                        var c = pq.poll();\n                        int curh = heightMap[c.i][c.j];\n                        if(curh > bottom){\n                            ans += (curh - bottom) * count;\n                            bottom = curh;\n                        }\n                        if(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1)break;\n                        if(!used[c.i][c.j]){\n                            count++;\n                        }\n                        used[c.i][c.j] = true;\n                        for(int d = 0; d<4; d++){\n                            int x = c.i+dir[d], y = c.j+dir[d+1];\n                            if(x < 0 || y < 0 || x >= m || y >= n || visited[x][y])continue;\n                            visited[x][y] = true;\n                            pq.offer(new Cell(x, y));\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n```\n## 解答\nThe code attempts to solve the **Trapping Rain Water II** problem, where water can be trapped in a 2D elevation map. However, the implementation contains several **logical and structural errors**, which prevent it from working correctly.\n\n---\n\n### ✅ Overall Idea\n\nThe idea is based on using a **priority queue (min-heap)** to simulate the process of water flowing from the boundary inward, similar to Dijkstra's algorithm:\n\n- Start from the **border cells** as boundaries cannot trap water.\n- Use a **min-heap** to always process the lowest height cell next.\n- As you expand inward, any lower area surrounded by higher walls can potentially trap water.\n\nThis is a valid approach for this problem.\n\n---\n\n### ❌ Key Implementation Errors\n\n#### 1. **Incorrect BFS/Heap Usage**\n```java\nif(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1) break;\n```\n- This line breaks the search when reaching any border cell.\n- **Problem**: The algorithm should start from the borders and explore inward. Instead, it stops as soon as it reaches a border, effectively ignoring the correct flow logic.\n\n#### 2. **Misuse of `used` and `visited`**\n- `used` seems to mark whether a cell has been processed globally, while `visited` is reinitialized in each loop.\n- **Problem**: The inner BFS (`pq`) is not tracking global visited status properly, leading to:\n  - Re-processing of already visited regions.\n  - Incomplete traversal.\n\n#### 3. **Wrong Calculation of Trapped Water**\n```java\nif(!used[c.i][c.j]){\n    count++;\n}\n```\n- `count` is used to track how many cells are in the current basin.\n- **Problem**: It doesn't account for the actual volume of water trapped per unit height difference correctly.\n- Also, `used[i][j] = true;` is set after checking, which may cause incorrect counting.\n\n#### 4. **Use of Local Class Inside Method (Java 16+ only)**\n```java\nrecord Cell(int i, int j) implements Comparable<Cell>\n```\n- **Issue**: This uses a local record inside a method, which is only supported in Java 16+. If the environment supports it, that's fine, but if not, it will fail to compile.\n\nAlso, the `compareTo` method uses `fh[i][j]`, but `fh` is a class-level variable (`this.fh`). This could lead to confusion or bugs if `fh` changes during execution.\n\n#### 5. **Redundant Outer Loop**\n- The outer double loop over all `(i,j)` is unnecessary.\n- **Correct approach**: Initialize the heap with all border cells first, then expand inward — no need to re-start BFS from every unvisited cell.\n\n---\n\n### 🛠️ Suggested Fixes\n\n#### ✔️ Corrected Algorithm Outline\n\n1. **Initialize a min-heap** with all the border cells.\n2. Maintain a global `visited` matrix.\n3. While the heap is not empty:\n   - Pop the lowest cell.\n   - For its four neighbors:\n     - If not visited:\n       - If neighbor is lower than current height, it can trap water.\n       - Add neighbor to the heap with its own height.\n4. Accumulate trapped water accordingly.\n\n#### ✔️ Code Skeleton Fix\n\n```java\npublic int trapRainWater(int[][] heightMap) {\n    if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)\n        return 0;\n\n    int m = heightMap.length, n = heightMap[0].length;\n    boolean[][] visited = new boolean[m][n];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // x, y, height\n    int[] dirs = {0, 1, 0, -1, 0};\n\n    // Initialize with boundary cells\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n                pq.offer(new int[]{i, j, heightMap[i][j]});\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    int res = 0;\n    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int maxHeight = 0;\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int x = curr[0], y = curr[1], h = curr[2];\n        maxHeight = Math.max(maxHeight, h);\n\n        for (int[] dir : directions) {\n            int nx = x + dir[0], ny = y + dir[1];\n            if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                if (heightMap[nx][ny] < maxHeight) {\n                    res += maxHeight - heightMap[nx][ny];\n                }\n                pq.offer(new int[]{nx, ny, Math.max(maxHeight, heightMap[nx][ny])});\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n---\n\n### ✅ Summary\n\n| Aspect | Evaluation |\n|-------|------------|\n| **Algorithm Design** | Partially correct conceptually, but flawed in implementation |\n| **Data Structures** | Priority Queue used incorrectly |\n| **Visited Tracking** | Confusing and incorrect |\n| **Water Calculation** | Incorrect logic |\n| **Code Structure** | Poor modularity and readability |\n\n---\n\n### 📌 Conclusion\n\nWhile the general idea of using a priority queue to simulate water flow is sound, the current implementation fails due to incorrect handling of visited nodes, early termination, and wrong calculation of trapped water. A revised version using a proper BFS-like approach with a min-heap and global visited tracking is necessary for correctness.\n\n## 问题\n这种思维模式踩中了哪个误区？试着从更高维度分解这种思维模式的问题。（能够理解正确的做法是简洁的，模拟水位上涨逐渐淹没所有位置，第一次淹没时的高差，就是 trap 的水体积，正确的做法足够简洁清晰）。\nThis code's thought process falls into a **\"局部贪心 + 多重嵌套状态\"** thinking trap. It attempts to simulate the water trapping process by treating each basin separately and trying to compute local trapped water using nested loops and conditions.\n\n---\n\n### 🧠 高维思维模式分析（Higher-Level Pattern Analysis）\n\n#### 1. **误区名称：局部模拟陷阱 / 分治式暴力（Local Simulation Fallacy）**\n\nThe developer tried to simulate water filling **locally**, assuming that each \"valley\" or enclosed area can be processed independently, starting from any unvisited cell.\n\n##### 🔍 特征：\n- 使用 `for` 循环从每个未访问的点出发，尝试“独立”处理。\n- 每次 BFS 都试图计算当前区域的积水体积。\n- 没有统一水位上涨模型，而是分块处理。\n\n##### ❌ 问题本质：\n- 忽视了全局水位逐渐上升这一物理过程。\n- 把问题拆解为多个子问题，反而引入复杂边界条件和重复计算。\n- 用 `used[][]` 和 `visited[][]` 来防止重复访问，但逻辑混乱导致错误。\n\n---\n\n#### 2. **认知维度：没有抽象出核心变量（Failure to Abstract Core Variables）**\n\n正确的做法中，**maxHeight** 是一个核心抽象变量，它代表当前的“水位线”。\n\n##### ✅ 正确视角：\n- 所有积水都发生在某一点低于当前水位时。\n- 水位是单调不降的，随着优先队列弹出最小高度而逐步升高。\n- 每个点只被访问一次，避免重复判断和错误积累。\n\n##### ❌ 错误视角：\n- 没有建立“全局水位”的抽象，而是依赖局部比较（如 `curh > bottom`）。\n- 将 `bottom` 当作某种基准高度，但实际上它不具备全局一致性。\n- 没有意识到“第一次淹没”这个关键事件的价值。\n\n---\n\n#### 3. **算法设计误区：忽视最优子结构（Ignoring Optimal Substructure）**\n\n这道题具有典型的**最短路径/最小堆扩展**性质：\n\n##### ✅ 正确方法的本质：\n- 利用最小堆维护当前最低边界。\n- 每次扩展最低点，确保当前水位是最小可淹没高度。\n- 类似于 Dijkstra 算法中的松弛操作。\n\n##### ❌ 错误方法的问题：\n- 没有利用优先队列的“最小高度优先”特性来驱动整个搜索流程。\n- 混合使用了 BFS、DFS 和贪心策略，导致状态失控。\n\n---\n\n### 🧩 思维模式高维分解图\n\n| 维度 | 错误模式 | 正确模式 |\n|------|----------|-----------|\n| **抽象层级** | 局部模拟，缺乏统一水位抽象 | 全局水位上涨模型 |\n| **控制流结构** | 多层嵌套循环 + 多重条件分支 | 单一优先队列驱动流程 |\n| **数据结构使用** | 堆仅用于局部搜索 | 堆驱动全局扩展顺序 |\n| **访问机制** | 双重 visited 控制，逻辑混乱 | 单一 visited + 最早访问即最早淹没 |\n| **问题建模方式** | 分治处理每个“坑” | 整体地形洪水模拟 |\n\n---\n\n### 🧭 认知升级建议\n\n要跳出这类思维误区，可以尝试以下思维方式：\n\n#### ✅ 1. **寻找核心抽象变量**\n- 在本题中，“当前水位”就是唯一重要的变量。\n- 所有操作都应该围绕它进行更新和比较。\n\n#### ✅ 2. **用物理过程类比算法行为**\n- 想象真实的水慢慢上涨的过程。\n- 这样能自然引导出优先队列和水位递增的思路。\n\n#### ✅ 3. **追求“事件驱动”的编程思想**\n- 每个点被访问时是一个“事件”，触发水位更新。\n- 而不是用循环去“强行”遍历所有可能。\n\n#### ✅ 4. **简化问题而非复杂化处理**\n- 不要试图在代码里解决所有边界情况。\n- 如果一个问题看起来很复杂，那可能是建模方式错了。\n\n---\n\n### 🎯 结语\n\n这段代码本质上踩进了“**微观模拟陷阱**”：试图从细节上还原每一个积水场景，却忽略了整体系统的行为规律。真正的高效解法往往来源于对系统宏观行为的理解与建模。\n\n“聪明的算法不在于写得多复杂，而在于抓住那个最简单的物理规则。”"},{"metadata":{"title":"The Core Lies In Modeling","description":"Comparison of computer algorithm competitions and university-level mathematical or simulation modeling competitions","imgName":"modeling-as-a-core/modeling-as-a-core.png","date":"Jul 1, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","modeling","math"],"id":"modeling-as-a-core"},"content":"![The Core Lies In Modeling](modeling-as-a-core/modeling-as-a-core.png)\n \n###### Published on: **Jul 1, 2025**\n\nYes, the \"modeling\" in both computer algorithm competitions and university-level mathematical or simulation modeling competitions follows similar principles, though they differ in focus and application domains.\n\n### Key Similarities:\n1. **Problem Abstraction**:\n   - In both cases, the core lies in abstracting a real-world or problem scenario into a simplified **model**, which could be represented by variables, relationships, constraints, or rules.\n   \n2. **Use of Variables and Relationships**:\n   - In programming contests, you often define key variables (e.g., `dp[i][j]` for dynamic programming) to capture states.\n   - In university modeling contests, you similarly define variables (e.g., `x(t)` for time-dependent systems) and relationships (e.g., differential equations, statistical models).\n\n3. **Mathematical or Logical Formulation**:\n   - Both require translating the problem into a precise formulation—be it an algorithmic model, a mathematical equation system, or a graph structure.\n\n4. **Computational Tools/Data Structures**:\n   - After building the model, appropriate data structures (like trees, graphs, arrays) or computational tools (like MATLAB, Python, or optimization libraries) are used to simulate, compute, or optimize the solution.\n\n### Differences:\n| Aspect | Algorithm Competitions | University Modeling Competitions |\n|--------|------------------------|----------------------------------|\n| Focus  | Efficiency, correctness, speed | Accuracy, realism, scalability |\n| Tools Used | Code (C++, Python, etc.) | Simulation tools, statistics, sometimes code |\n| Output | Program solving a specific task | Report + possibly simulation/model |\n| Timeframe | Short (hours) | Long (days or weeks) |\n\nIn summary, the process of **modeling** in both settings shares a common foundation: identifying the right abstractions and formalizing them to enable effective computation or analysis."}],"tags":["algorithm","thought-process","model","simulation","template"]},"__N_SSG":true}