{"pageProps":{"postMetadata":{"title":"Perception On Tree Traversal","description":"Key perceptions about efficient tree traversal","imgName":"perception-on-tree-traversal/perception-on-tree-traversal.png","date":"Jul 30, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"xor-link-tree-and-leaf-peeling"},"postContent":{"compiledSource":"var c=Object.defineProperty,g=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var r=Object.getOwnPropertySymbols;var o=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable;var s=(e,n,t)=>n in e?c(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,i=(e,n)=>{for(var t in n||(n={}))o.call(n,t)&&s(e,t,n[t]);if(r)for(var t of r(n))l.call(n,t)&&s(e,t,n[t]);return e},p=(e,n)=>g(e,m(n));var u=(e,n)=>{var t={};for(var a in e)o.call(e,a)&&n.indexOf(a)<0&&(t[a]=e[a]);if(e!=null&&r)for(var a of r(e))n.indexOf(a)<0&&l.call(e,a)&&(t[a]=e[a]);return t};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(t){var a=t,{components:e}=a,n=u(a,[\"components\"]);return mdx(MDXLayout,p(i(i({},layoutProps),n),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"img\",i({parentName:\"p\"},{src:\"perception-on-tree-traversal/perception-on-tree-traversal.png\",alt:\"Perception On Tree Traversal\"}))),mdx(\"h6\",null,\"Published on: \",mdx(\"strong\",{parentName:\"h6\"},\"Jul 30, 2025\")),mdx(\"h2\",null,\"Case Study: perception on the following implementation\"),mdx(\"p\",null,\"problem id : maximize-the-number-of-target-nodes-after-connecting-trees-ii\"),mdx(\"pre\",null,mdx(\"code\",i({parentName:\"pre\"},{className:\"language-java\"}),`class Solution {\n    public int[] maxTargetNodes(int[][] edges1, int[][] edges2) {\n        final int[] targets1 = computeTargets(edges1);\n        final int offset = findMax(computeTargets(edges2));\n        for (int i = 0; i < targets1.length; i++) {\n            targets1[i] += offset;\n        }\n        return targets1;\n    }\n\n    static final int findMax(int[] values) {\n        int maximum = 0;\n        for (int val : values) {\n            maximum = Math.max(maximum, val);\n        }\n        return maximum;\n    }\n\n    static int[] computeTargets(int[][] connections) {\n        final int nodeCount = connections.length + 1;\n        final int[] edgeCount = new int[nodeCount];\n        final int[] xorLink = new int[nodeCount];\n        final int[] result = new int[nodeCount];\n        Arrays.fill(result, 1);\n        final int[] stack = new int[nodeCount];\n\n        for (int[] pair : connections) {\n            final int u = pair[0];\n            final int v = pair[1];\n            edgeCount[u]++;\n            edgeCount[v]++;\n            xorLink[u] ^= v;\n            xorLink[v] ^= u;\n        }\n\n        int stackLength = 0;\n        for (int i = 0; i < nodeCount; i++) {\n            if (edgeCount[i] == 1) {\n                stack[stackLength++] = i;\n            }\n        }\n\n        for (int i = 0; i < connections.length; i++) {\n            final int current = stack[i];\n            final int parent = xorLink[current];\n            xorLink[parent] ^= current;\n            result[parent] -= result[current];\n            if (--edgeCount[parent] == 1) {\n                stack[stackLength++] = parent;\n            }\n        }\n\n        final int central = stack[nodeCount - 1];\n        result[central] = (nodeCount + result[central]) / 2;\n\n        for (int i = nodeCount - 2; i >= 0; i--) {\n            final int current = stack[i];\n            result[current] = nodeCount - result[xorLink[current]];\n        }\n\n        return result;\n    }\n}\n`)),mdx(\"p\",null,\"The XOR-linked tree representation is a space-efficient technique for representing trees. Here are the core insights:\"),mdx(\"h2\",null,\"Key Insights of XOR-Linked Tree Representation\"),mdx(\"h3\",null,\"1. \",mdx(\"strong\",{parentName:\"h3\"},\"Space Efficiency\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Instead of storing adjacency lists or matrices, only two arrays are needed:\",mdx(\"ul\",{parentName:\"li\"},mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"xorLink[]\"),\": Stores XOR of all neighbors for each node\"),mdx(\"li\",{parentName:\"ul\"},mdx(\"inlineCode\",{parentName:\"li\"},\"edgeCount[]\"),\": Stores degree of each node\"))),mdx(\"li\",{parentName:\"ul\"},\"Space complexity: O(n) instead of O(n + m) for adjacency list\")),mdx(\"h3\",null,\"2. \",mdx(\"strong\",{parentName:\"h3\"},\"XOR Properties for Tree Traversal\")),mdx(\"pre\",null,mdx(\"code\",i({parentName:\"pre\"},{className:\"language-text\"}),`If node A is connected to nodes B, C, D:\nxorLink[A] = B \\u2295 C \\u2295 D\n\nTo find a specific neighbor (e.g., B), if you know the others:\nB = xorLink[A] \\u2295 C \\u2295 D\n`)),mdx(\"h3\",null,\"3. \",mdx(\"strong\",{parentName:\"h3\"},\"Leaf Peeling Algorithm Core Insight\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Start with leaves (nodes with degree 1)\"),mdx(\"li\",{parentName:\"ul\"},\"Process nodes in leaf-to-root order\"),mdx(\"li\",{parentName:\"ul\"},\"When removing a leaf, update its parent's information\")),mdx(\"h3\",null,\"4. \",mdx(\"strong\",{parentName:\"h3\"},\"Key Operations\")),mdx(\"pre\",null,mdx(\"code\",i({parentName:\"pre\"},{className:\"language-java\"}),`// Building XOR links\nfor (int[] pair : connections) {\n    xorLink[u] ^= v;  // Add v to u's neighbor list\n    xorLink[v] ^= u;  // Add u to v's neighbor list\n}\n\n// Finding parent of a leaf node\nint parent = xorLink[leaf];  // Works because leaf has only one neighbor\n\n// Removing leaf from parent\nxorLink[parent] ^= leaf;     // Remove leaf from parent's neighbor list\n`)),mdx(\"h2\",null,\"Algorithm Core Insight\"),mdx(\"p\",null,\"The traversal algorithm uses a \",mdx(\"strong\",{parentName:\"p\"},\"topological processing approach\"),\":\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},mdx(\"strong\",{parentName:\"li\"},\"Leaf Queue Construction\"),\": Identify all initial leaves (degree = 1)\"),mdx(\"li\",{parentName:\"ol\"},mdx(\"strong\",{parentName:\"li\"},\"Leaf Processing\"),\": Process leaves in FIFO order\"),mdx(\"li\",{parentName:\"ol\"},mdx(\"strong\",{parentName:\"li\"},\"Tree Shrinking\"),\": When a leaf is processed, its parent may become a new leaf\"),mdx(\"li\",{parentName:\"ol\"},mdx(\"strong\",{parentName:\"li\"},\"Information Propagation\"),\": Maintain subtree size relationships during processing\")),mdx(\"h2\",null,\"Mathematical Insight\"),mdx(\"p\",null,\"The key mathematical insight for computing targets:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"For any node, targets = nodes reachable via even-length paths\"),mdx(\"li\",{parentName:\"ul\"},\"This equals: \",mdx(\"inlineCode\",{parentName:\"li\"},\"(total_nodes + subtree_size) / 2\"),\" for the root\"),mdx(\"li\",{parentName:\"ul\"},\"For other nodes: if we know parent's target count, child's = \",mdx(\"inlineCode\",{parentName:\"li\"},\"total - parent_target\"))),mdx(\"p\",null,\"This representation is particularly elegant because:\"),mdx(\"ol\",null,mdx(\"li\",{parentName:\"ol\"},\"It eliminates the need for complex graph data structures\"),mdx(\"li\",{parentName:\"ol\"},\"It enables purely arithmetic operations for traversal\"),mdx(\"li\",{parentName:\"ol\"},\"It naturally supports the leaf-peeling algorithm\"),mdx(\"li\",{parentName:\"ol\"},\"It's cache-friendly with sequential memory access patterns\")))}MDXContent.isMDXComponent=!0;\n","scope":{}},"id":"xor-link-tree-and-leaf-peeling","tags":["algorithm","thought-process","model","simulation","template"]},"__N_SSG":true}