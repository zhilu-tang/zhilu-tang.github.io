{"pageProps":{"postsMetaData":[{"metadata":{"title":"Perception On Rolling Hash","description":"Key perceptions about Rolling Hash for Strings, pitfalls, and best practices","imgName":"perception-on-rolling-hash/perception-on-rolling-hash.png","date":"Jul 24, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"on-rolling-hash"},"content":"![Perception On Rolling Hash](perception-on-rolling-hash/perception-on-rolling-hash.png)\n \n###### Published on: **Jul 24, 2025**\n\n## üîë Key Insights about Rolling Hash for Strings\n\nRolling hash is a powerful technique for string processing that allows efficient computation and comparison of substring hashes. Here are the essential insights:\n\n### 1. **Core Principle**\n- Compute hash values for substrings using polynomial hashing\n- Formula: `hash(s[0...n-1]) = s[0]*p^(n-1) + s[1]*p^(n-2) + ... + s[n-1]*p^0`\n- Enable O(1) computation of any substring hash from precomputed prefix hashes\n\n### 2. **Rolling Property**\n- Given hash of substring `s[i...j]`, can compute hash of `s[i+1...j+1]` in O(1)\n- This property makes it ideal for sliding window algorithms\n\n### 3. **Preprocessing Advantage**\n- Compute all prefix hashes in O(n) time\n- Any substring hash can be computed in O(1) time afterward\n\n## ‚ö†Ô∏è Key Problems and Collision Issues\n\n### 1. **Hash Collisions**\n```java\n// Example of collision (simplified)\n// Two different strings might have same hash value\nString s1 = \"abc\", s2 = \"def\";\n// With certain BASE/MOD, hash(s1) might equal hash(s2)\n```\n\n### 2. **Modulo Arithmetic Limitations**\n- Using finite MOD space means collisions are inevitable\n- Birthday paradox: collisions occur more frequently than expected\n\n### 3. **Poor Parameter Choices**\n- Small BASE or MOD values increase collision probability\n- Powers of 2 as BASE can lead to poor distribution\n\n## üõ°Ô∏è Mitigation Strategies\n\n### 1. **Double Hashing**\n```java\nclass DoubleHash {\n    private static final long BASE1 = 31, BASE2 = 37;\n    private static final long MOD1 = 1000000007, MOD2 = 1000000009;\n    \n    // Use pair of hashes to reduce collision probability\n    long hash1, hash2;\n    \n    // Compare both hash values for equality\n    public boolean equals(Object other) {\n        DoubleHash o = (DoubleHash) other;\n        return hash1 == o.hash1 && hash2 == o.hash2;\n    }\n}\n```\n\n### 2. **Large Prime Parameters**\n- Use large primes for MOD (e.g., 10^9+7, 10^9+9)\n- Choose BASE that's relatively prime to MOD\n- Avoid powers of 2 or small primes for BASE\n\n### 3. **Verification for Critical Applications**\n```java\n// When hash matches, verify actual string equality if correctness is critical\nif (hash1 == hash2) {\n    // Only do expensive string comparison when hashes match\n    if (actualStringComparison(str1, str2)) {\n        // Truly equal\n    }\n}\n```\n\n### 4. **Good Parameter Selection**\n- BASE: Use prime numbers (commonly 31, 37, 41, 43)\n- MOD: Use large primes (10^9+7, 10^9+9, or even larger)\n- Avoid BASE=2, 10 which have poor distribution properties\n\n## üéØ When to Use Rolling Hash\n\n### ‚úÖ Good Use Cases:\n- String matching algorithms (Rabin-Karp)\n- Finding duplicate substrings\n- Palindrome detection\n- Counting distinct substrings\n- When approximate equality is acceptable\n\n### ‚ùå Avoid When:\n- Cryptographic security is required\n- Exact string matching is critical without verification\n- Very small strings where overhead doesn't pay off\n\n## üí° Best Practices\n\n### 1. **Always Consider Collision Probability**\n- For n strings, collision probability is roughly n¬≤/(2*MOD)\n- Choose MOD appropriately for your data size\n\n### 2. **Precompute Powers**\n```java\n// Precompute powers of BASE to avoid repeated calculations\nlong[] powers = new long[n];\npowers[0] = 1;\nfor (int i = 1; i < n; i++) {\n    powers[i] = (powers[i-1] * BASE) % MOD;\n}\n```\n\n### 3. **Handle Negative Results**\n```java\n// Always ensure hash values are positive\nlong hash = (computed_hash % MOD + MOD) % MOD;\n```\n\n### 4. **Memory vs Time Tradeoff**\n- Decide whether to precompute all substring hashes or compute on demand\n- Consider the specific problem constraints\n\nRolling hash is a powerful tool when used correctly, but requires careful consideration of parameters and collision handling to ensure reliable results."},{"metadata":{"title":"Daily Thought Fallacies","description":"A case study about a trapped thought process.","imgName":"daily-thought-fallacies/daily-thought-fallacies.png","date":"Jul 1, 2025","tags":["algorithm","thought-process"],"keywords":["trap","algorithm","thought"],"id":"daily-thought-fallacies"},"content":"![Daily thought fallacies](daily-thought-fallacies/daily-thought-fallacies.png)\n \n###### Published on: **Jul 1, 2025**\n\n## ÈóÆÈ¢ò\n### ËØÑ‰ª∑‰∏ãÈù¢‰ª£Á†ÅÁöÑÊï¥‰ΩìÊÄùË∑Ø„ÄÅÂÖ≥ÈîÆÂÆûÁé∞ÂØπÈîô\n```java\n    static int[][] fh;\n    public int trapRainWaterWA2(int[][] heightMap) {\n        fh = heightMap;\n        int m = heightMap.length, n = heightMap[0].length;\n        int dir[] = {1,0,-1,0,1};\n        int ans = 0;\n        record Cell(int i, int j) implements Comparable<Cell>{\n            public int compareTo(Cell o){\n                return fh[i][j] - fh[o.i][o.j];\n            }\n        }\n        PriorityQueue<Cell> pq = new PriorityQueue<Cell>();\n        boolean used[][] = new boolean[m][n], visited[][];\n        for(int i = 0; i<m; i++){\n            for(int j = 0; j<n; j++){\n                if(!used[i][j]){\n                    pq.clear();\n                    visited = new boolean[m][n];\n                    // start\n                    var start = new Cell(i,j);\n                    pq.offer(start);\n                    visited[i][j] = true;\n                    used[i][j] = true;\n                    int bottom = heightMap[i][j], count = 0;\n                    while(!pq.isEmpty()){\n                        var c = pq.poll();\n                        int curh = heightMap[c.i][c.j];\n                        if(curh > bottom){\n                            ans += (curh - bottom) * count;\n                            bottom = curh;\n                        }\n                        if(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1)break;\n                        if(!used[c.i][c.j]){\n                            count++;\n                        }\n                        used[c.i][c.j] = true;\n                        for(int d = 0; d<4; d++){\n                            int x = c.i+dir[d], y = c.j+dir[d+1];\n                            if(x < 0 || y < 0 || x >= m || y >= n || visited[x][y])continue;\n                            visited[x][y] = true;\n                            pq.offer(new Cell(x, y));\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n```\n## Ëß£Á≠î\nThe code attempts to solve the **Trapping Rain Water II** problem, where water can be trapped in a 2D elevation map. However, the implementation contains several **logical and structural errors**, which prevent it from working correctly.\n\n---\n\n### ‚úÖ Overall Idea\n\nThe idea is based on using a **priority queue (min-heap)** to simulate the process of water flowing from the boundary inward, similar to Dijkstra's algorithm:\n\n- Start from the **border cells** as boundaries cannot trap water.\n- Use a **min-heap** to always process the lowest height cell next.\n- As you expand inward, any lower area surrounded by higher walls can potentially trap water.\n\nThis is a valid approach for this problem.\n\n---\n\n### ‚ùå Key Implementation Errors\n\n#### 1. **Incorrect BFS/Heap Usage**\n```java\nif(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1) break;\n```\n- This line breaks the search when reaching any border cell.\n- **Problem**: The algorithm should start from the borders and explore inward. Instead, it stops as soon as it reaches a border, effectively ignoring the correct flow logic.\n\n#### 2. **Misuse of `used` and `visited`**\n- `used` seems to mark whether a cell has been processed globally, while `visited` is reinitialized in each loop.\n- **Problem**: The inner BFS (`pq`) is not tracking global visited status properly, leading to:\n  - Re-processing of already visited regions.\n  - Incomplete traversal.\n\n#### 3. **Wrong Calculation of Trapped Water**\n```java\nif(!used[c.i][c.j]){\n    count++;\n}\n```\n- `count` is used to track how many cells are in the current basin.\n- **Problem**: It doesn't account for the actual volume of water trapped per unit height difference correctly.\n- Also, `used[i][j] = true;` is set after checking, which may cause incorrect counting.\n\n#### 4. **Use of Local Class Inside Method (Java 16+ only)**\n```java\nrecord Cell(int i, int j) implements Comparable<Cell>\n```\n- **Issue**: This uses a local record inside a method, which is only supported in Java 16+. If the environment supports it, that's fine, but if not, it will fail to compile.\n\nAlso, the `compareTo` method uses `fh[i][j]`, but `fh` is a class-level variable (`this.fh`). This could lead to confusion or bugs if `fh` changes during execution.\n\n#### 5. **Redundant Outer Loop**\n- The outer double loop over all `(i,j)` is unnecessary.\n- **Correct approach**: Initialize the heap with all border cells first, then expand inward ‚Äî no need to re-start BFS from every unvisited cell.\n\n---\n\n### üõ†Ô∏è Suggested Fixes\n\n#### ‚úîÔ∏è Corrected Algorithm Outline\n\n1. **Initialize a min-heap** with all the border cells.\n2. Maintain a global `visited` matrix.\n3. While the heap is not empty:\n   - Pop the lowest cell.\n   - For its four neighbors:\n     - If not visited:\n       - If neighbor is lower than current height, it can trap water.\n       - Add neighbor to the heap with its own height.\n4. Accumulate trapped water accordingly.\n\n#### ‚úîÔ∏è Code Skeleton Fix\n\n```java\npublic int trapRainWater(int[][] heightMap) {\n    if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)\n        return 0;\n\n    int m = heightMap.length, n = heightMap[0].length;\n    boolean[][] visited = new boolean[m][n];\n    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // x, y, height\n    int[] dirs = {0, 1, 0, -1, 0};\n\n    // Initialize with boundary cells\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n                pq.offer(new int[]{i, j, heightMap[i][j]});\n                visited[i][j] = true;\n            }\n        }\n    }\n\n    int res = 0;\n    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    int maxHeight = 0;\n\n    while (!pq.isEmpty()) {\n        int[] curr = pq.poll();\n        int x = curr[0], y = curr[1], h = curr[2];\n        maxHeight = Math.max(maxHeight, h);\n\n        for (int[] dir : directions) {\n            int nx = x + dir[0], ny = y + dir[1];\n            if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                if (heightMap[nx][ny] < maxHeight) {\n                    res += maxHeight - heightMap[nx][ny];\n                }\n                pq.offer(new int[]{nx, ny, Math.max(maxHeight, heightMap[nx][ny])});\n            }\n        }\n    }\n\n    return res;\n}\n```\n\n---\n\n### ‚úÖ Summary\n\n| Aspect | Evaluation |\n|-------|------------|\n| **Algorithm Design** | Partially correct conceptually, but flawed in implementation |\n| **Data Structures** | Priority Queue used incorrectly |\n| **Visited Tracking** | Confusing and incorrect |\n| **Water Calculation** | Incorrect logic |\n| **Code Structure** | Poor modularity and readability |\n\n---\n\n### üìå Conclusion\n\nWhile the general idea of using a priority queue to simulate water flow is sound, the current implementation fails due to incorrect handling of visited nodes, early termination, and wrong calculation of trapped water. A revised version using a proper BFS-like approach with a min-heap and global visited tracking is necessary for correctness.\n\n## ÈóÆÈ¢ò\nËøôÁßçÊÄùÁª¥Ê®°ÂºèË∏©‰∏≠‰∫ÜÂì™‰∏™ËØØÂå∫ÔºüËØïÁùÄ‰ªéÊõ¥È´òÁª¥Â∫¶ÂàÜËß£ËøôÁßçÊÄùÁª¥Ê®°ÂºèÁöÑÈóÆÈ¢ò„ÄÇÔºàËÉΩÂ§üÁêÜËß£Ê≠£Á°ÆÁöÑÂÅöÊ≥ïÊòØÁÆÄÊ¥ÅÁöÑÔºåÊ®°ÊãüÊ∞¥‰Ωç‰∏äÊ∂®ÈÄêÊ∏êÊ∑πÊ≤°ÊâÄÊúâ‰ΩçÁΩÆÔºåÁ¨¨‰∏ÄÊ¨°Ê∑πÊ≤°Êó∂ÁöÑÈ´òÂ∑ÆÔºåÂ∞±ÊòØ trap ÁöÑÊ∞¥‰ΩìÁßØÔºåÊ≠£Á°ÆÁöÑÂÅöÊ≥ïË∂≥Â§üÁÆÄÊ¥ÅÊ∏ÖÊô∞Ôºâ„ÄÇ\nThis code's thought process falls into a **\"Â±ÄÈÉ®Ë¥™ÂøÉ + Â§öÈáçÂµåÂ•óÁä∂ÊÄÅ\"** thinking trap. It attempts to simulate the water trapping process by treating each basin separately and trying to compute local trapped water using nested loops and conditions.\n\n---\n\n### üß† È´òÁª¥ÊÄùÁª¥Ê®°ÂºèÂàÜÊûêÔºàHigher-Level Pattern AnalysisÔºâ\n\n#### 1. **ËØØÂå∫ÂêçÁß∞ÔºöÂ±ÄÈÉ®Ê®°ÊãüÈô∑Èò± / ÂàÜÊ≤ªÂºèÊö¥ÂäõÔºàLocal Simulation FallacyÔºâ**\n\nThe developer tried to simulate water filling **locally**, assuming that each \"valley\" or enclosed area can be processed independently, starting from any unvisited cell.\n\n##### üîç ÁâπÂæÅÔºö\n- ‰ΩøÁî® `for` Âæ™ÁéØ‰ªéÊØè‰∏™Êú™ËÆøÈóÆÁöÑÁÇπÂá∫ÂèëÔºåÂ∞ùËØï‚ÄúÁã¨Á´ã‚ÄùÂ§ÑÁêÜ„ÄÇ\n- ÊØèÊ¨° BFS ÈÉΩËØïÂõæËÆ°ÁÆóÂΩìÂâçÂå∫ÂüüÁöÑÁßØÊ∞¥‰ΩìÁßØ„ÄÇ\n- Ê≤°ÊúâÁªü‰∏ÄÊ∞¥‰Ωç‰∏äÊ∂®Ê®°ÂûãÔºåËÄåÊòØÂàÜÂùóÂ§ÑÁêÜ„ÄÇ\n\n##### ‚ùå ÈóÆÈ¢òÊú¨Ë¥®Ôºö\n- ÂøΩËßÜ‰∫ÜÂÖ®Â±ÄÊ∞¥‰ΩçÈÄêÊ∏ê‰∏äÂçáËøô‰∏ÄÁâ©ÁêÜËøáÁ®ã„ÄÇ\n- ÊääÈóÆÈ¢òÊãÜËß£‰∏∫Â§ö‰∏™Â≠êÈóÆÈ¢òÔºåÂèçËÄåÂºïÂÖ•Â§çÊùÇËæπÁïåÊù°‰ª∂ÂíåÈáçÂ§çËÆ°ÁÆó„ÄÇ\n- Áî® `used[][]` Âíå `visited[][]` Êù•Èò≤Ê≠¢ÈáçÂ§çËÆøÈóÆÔºå‰ΩÜÈÄªËæëÊ∑∑‰π±ÂØºËá¥ÈîôËØØ„ÄÇ\n\n---\n\n#### 2. **ËÆ§Áü•Áª¥Â∫¶ÔºöÊ≤°ÊúâÊäΩË±°Âá∫Ê†∏ÂøÉÂèòÈáèÔºàFailure to Abstract Core VariablesÔºâ**\n\nÊ≠£Á°ÆÁöÑÂÅöÊ≥ï‰∏≠Ôºå**maxHeight** ÊòØ‰∏Ä‰∏™Ê†∏ÂøÉÊäΩË±°ÂèòÈáèÔºåÂÆÉ‰ª£Ë°®ÂΩìÂâçÁöÑ‚ÄúÊ∞¥‰ΩçÁ∫ø‚Äù„ÄÇ\n\n##### ‚úÖ Ê≠£Á°ÆËßÜËßíÔºö\n- ÊâÄÊúâÁßØÊ∞¥ÈÉΩÂèëÁîüÂú®Êüê‰∏ÄÁÇπ‰Ωé‰∫éÂΩìÂâçÊ∞¥‰ΩçÊó∂„ÄÇ\n- Ê∞¥‰ΩçÊòØÂçïË∞É‰∏çÈôçÁöÑÔºåÈöèÁùÄ‰ºòÂÖàÈòüÂàóÂºπÂá∫ÊúÄÂ∞èÈ´òÂ∫¶ËÄåÈÄêÊ≠•ÂçáÈ´ò„ÄÇ\n- ÊØè‰∏™ÁÇπÂè™Ë¢´ËÆøÈóÆ‰∏ÄÊ¨°ÔºåÈÅøÂÖçÈáçÂ§çÂà§Êñ≠ÂíåÈîôËØØÁßØÁ¥Ø„ÄÇ\n\n##### ‚ùå ÈîôËØØËßÜËßíÔºö\n- Ê≤°ÊúâÂª∫Á´ã‚ÄúÂÖ®Â±ÄÊ∞¥‰Ωç‚ÄùÁöÑÊäΩË±°ÔºåËÄåÊòØ‰æùËµñÂ±ÄÈÉ®ÊØîËæÉÔºàÂ¶Ç `curh > bottom`Ôºâ„ÄÇ\n- Â∞Ü `bottom` ÂΩì‰ΩúÊüêÁßçÂü∫ÂáÜÈ´òÂ∫¶Ôºå‰ΩÜÂÆûÈôÖ‰∏äÂÆÉ‰∏çÂÖ∑Â§áÂÖ®Â±Ä‰∏ÄËá¥ÊÄß„ÄÇ\n- Ê≤°ÊúâÊÑèËØÜÂà∞‚ÄúÁ¨¨‰∏ÄÊ¨°Ê∑πÊ≤°‚ÄùËøô‰∏™ÂÖ≥ÈîÆ‰∫ã‰ª∂ÁöÑ‰ª∑ÂÄº„ÄÇ\n\n---\n\n#### 3. **ÁÆóÊ≥ïËÆæËÆ°ËØØÂå∫ÔºöÂøΩËßÜÊúÄ‰ºòÂ≠êÁªìÊûÑÔºàIgnoring Optimal SubstructureÔºâ**\n\nËøôÈÅìÈ¢òÂÖ∑ÊúâÂÖ∏ÂûãÁöÑ**ÊúÄÁü≠Ë∑ØÂæÑ/ÊúÄÂ∞èÂ†ÜÊâ©Â±ï**ÊÄßË¥®Ôºö\n\n##### ‚úÖ Ê≠£Á°ÆÊñπÊ≥ïÁöÑÊú¨Ë¥®Ôºö\n- Âà©Áî®ÊúÄÂ∞èÂ†ÜÁª¥Êä§ÂΩìÂâçÊúÄ‰ΩéËæπÁïå„ÄÇ\n- ÊØèÊ¨°Êâ©Â±ïÊúÄ‰ΩéÁÇπÔºåÁ°Æ‰øùÂΩìÂâçÊ∞¥‰ΩçÊòØÊúÄÂ∞èÂèØÊ∑πÊ≤°È´òÂ∫¶„ÄÇ\n- Á±ª‰ºº‰∫é Dijkstra ÁÆóÊ≥ï‰∏≠ÁöÑÊùæÂºõÊìç‰Ωú„ÄÇ\n\n##### ‚ùå ÈîôËØØÊñπÊ≥ïÁöÑÈóÆÈ¢òÔºö\n- Ê≤°ÊúâÂà©Áî®‰ºòÂÖàÈòüÂàóÁöÑ‚ÄúÊúÄÂ∞èÈ´òÂ∫¶‰ºòÂÖà‚ÄùÁâπÊÄßÊù•È©±Âä®Êï¥‰∏™ÊêúÁ¥¢ÊµÅÁ®ã„ÄÇ\n- Ê∑∑Âêà‰ΩøÁî®‰∫Ü BFS„ÄÅDFS ÂíåË¥™ÂøÉÁ≠ñÁï•ÔºåÂØºËá¥Áä∂ÊÄÅÂ§±Êéß„ÄÇ\n\n---\n\n### üß© ÊÄùÁª¥Ê®°ÂºèÈ´òÁª¥ÂàÜËß£Âõæ\n\n| Áª¥Â∫¶ | ÈîôËØØÊ®°Âºè | Ê≠£Á°ÆÊ®°Âºè |\n|------|----------|-----------|\n| **ÊäΩË±°Â±ÇÁ∫ß** | Â±ÄÈÉ®Ê®°ÊãüÔºåÁº∫‰πèÁªü‰∏ÄÊ∞¥‰ΩçÊäΩË±° | ÂÖ®Â±ÄÊ∞¥‰Ωç‰∏äÊ∂®Ê®°Âûã |\n| **ÊéßÂà∂ÊµÅÁªìÊûÑ** | Â§öÂ±ÇÂµåÂ•óÂæ™ÁéØ + Â§öÈáçÊù°‰ª∂ÂàÜÊîØ | Âçï‰∏Ä‰ºòÂÖàÈòüÂàóÈ©±Âä®ÊµÅÁ®ã |\n| **Êï∞ÊçÆÁªìÊûÑ‰ΩøÁî®** | Â†Ü‰ªÖÁî®‰∫éÂ±ÄÈÉ®ÊêúÁ¥¢ | Â†ÜÈ©±Âä®ÂÖ®Â±ÄÊâ©Â±ïÈ°∫Â∫è |\n| **ËÆøÈóÆÊú∫Âà∂** | ÂèåÈáç visited ÊéßÂà∂ÔºåÈÄªËæëÊ∑∑‰π± | Âçï‰∏Ä visited + ÊúÄÊó©ËÆøÈóÆÂç≥ÊúÄÊó©Ê∑πÊ≤° |\n| **ÈóÆÈ¢òÂª∫Ê®°ÊñπÂºè** | ÂàÜÊ≤ªÂ§ÑÁêÜÊØè‰∏™‚ÄúÂùë‚Äù | Êï¥‰ΩìÂú∞ÂΩ¢Ê¥™Ê∞¥Ê®°Êãü |\n\n---\n\n### üß≠ ËÆ§Áü•ÂçáÁ∫ßÂª∫ËÆÆ\n\nË¶ÅË∑≥Âá∫ËøôÁ±ªÊÄùÁª¥ËØØÂå∫ÔºåÂèØ‰ª•Â∞ùËØï‰ª•‰∏ãÊÄùÁª¥ÊñπÂºèÔºö\n\n#### ‚úÖ 1. **ÂØªÊâæÊ†∏ÂøÉÊäΩË±°ÂèòÈáè**\n- Âú®Êú¨È¢ò‰∏≠Ôºå‚ÄúÂΩìÂâçÊ∞¥‰Ωç‚ÄùÂ∞±ÊòØÂîØ‰∏ÄÈáçË¶ÅÁöÑÂèòÈáè„ÄÇ\n- ÊâÄÊúâÊìç‰ΩúÈÉΩÂ∫îËØ•Âõ¥ÁªïÂÆÉËøõË°åÊõ¥Êñ∞ÂíåÊØîËæÉ„ÄÇ\n\n#### ‚úÖ 2. **Áî®Áâ©ÁêÜËøáÁ®ãÁ±ªÊØîÁÆóÊ≥ïË°å‰∏∫**\n- ÊÉ≥Ë±°ÁúüÂÆûÁöÑÊ∞¥ÊÖ¢ÊÖ¢‰∏äÊ∂®ÁöÑËøáÁ®ã„ÄÇ\n- ËøôÊ†∑ËÉΩËá™ÁÑ∂ÂºïÂØºÂá∫‰ºòÂÖàÈòüÂàóÂíåÊ∞¥‰ΩçÈÄíÂ¢ûÁöÑÊÄùË∑Ø„ÄÇ\n\n#### ‚úÖ 3. **ËøΩÊ±Ç‚Äú‰∫ã‰ª∂È©±Âä®‚ÄùÁöÑÁºñÁ®ãÊÄùÊÉ≥**\n- ÊØè‰∏™ÁÇπË¢´ËÆøÈóÆÊó∂ÊòØ‰∏Ä‰∏™‚Äú‰∫ã‰ª∂‚ÄùÔºåËß¶ÂèëÊ∞¥‰ΩçÊõ¥Êñ∞„ÄÇ\n- ËÄå‰∏çÊòØÁî®Âæ™ÁéØÂéª‚ÄúÂº∫Ë°å‚ÄùÈÅçÂéÜÊâÄÊúâÂèØËÉΩ„ÄÇ\n\n#### ‚úÖ 4. **ÁÆÄÂåñÈóÆÈ¢òËÄåÈùûÂ§çÊùÇÂåñÂ§ÑÁêÜ**\n- ‰∏çË¶ÅËØïÂõæÂú®‰ª£Á†ÅÈáåËß£ÂÜ≥ÊâÄÊúâËæπÁïåÊÉÖÂÜµ„ÄÇ\n- Â¶ÇÊûú‰∏Ä‰∏™ÈóÆÈ¢òÁúãËµ∑Êù•ÂæàÂ§çÊùÇÔºåÈÇ£ÂèØËÉΩÊòØÂª∫Ê®°ÊñπÂºèÈîô‰∫Ü„ÄÇ\n\n---\n\n### üéØ ÁªìËØ≠\n\nËøôÊÆµ‰ª£Á†ÅÊú¨Ë¥®‰∏äË∏©Ëøõ‰∫Ü‚Äú**ÂæÆËßÇÊ®°ÊãüÈô∑Èò±**‚ÄùÔºöËØïÂõæ‰ªéÁªÜËäÇ‰∏äËøòÂéüÊØè‰∏Ä‰∏™ÁßØÊ∞¥Âú∫ÊôØÔºåÂç¥ÂøΩÁï•‰∫ÜÊï¥‰ΩìÁ≥ªÁªüÁöÑË°å‰∏∫ËßÑÂæã„ÄÇÁúüÊ≠£ÁöÑÈ´òÊïàËß£Ê≥ïÂæÄÂæÄÊù•Ê∫ê‰∫éÂØπÁ≥ªÁªüÂÆèËßÇË°å‰∏∫ÁöÑÁêÜËß£‰∏éÂª∫Ê®°„ÄÇ\n\n‚ÄúËÅ™ÊòéÁöÑÁÆóÊ≥ï‰∏çÂú®‰∫éÂÜôÂæóÂ§öÂ§çÊùÇÔºåËÄåÂú®‰∫éÊäì‰ΩèÈÇ£‰∏™ÊúÄÁÆÄÂçïÁöÑÁâ©ÁêÜËßÑÂàô„ÄÇ‚Äù"},{"metadata":{"title":"The Core Lies In Modeling","description":"Comparison of computer algorithm competitions and university-level mathematical or simulation modeling competitions","imgName":"modeling-as-a-core/modeling-as-a-core.png","date":"Jul 1, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","modeling","math"],"id":"modeling-as-a-core"},"content":"![The Core Lies In Modeling](modeling-as-a-core/modeling-as-a-core.png)\n \n###### Published on: **Jul 1, 2025**\n\nYes, the \"modeling\" in both computer algorithm competitions and university-level mathematical or simulation modeling competitions follows similar principles, though they differ in focus and application domains.\n\n### Key Similarities:\n1. **Problem Abstraction**:\n   - In both cases, the core lies in abstracting a real-world or problem scenario into a simplified **model**, which could be represented by variables, relationships, constraints, or rules.\n   \n2. **Use of Variables and Relationships**:\n   - In programming contests, you often define key variables (e.g., `dp[i][j]` for dynamic programming) to capture states.\n   - In university modeling contests, you similarly define variables (e.g., `x(t)` for time-dependent systems) and relationships (e.g., differential equations, statistical models).\n\n3. **Mathematical or Logical Formulation**:\n   - Both require translating the problem into a precise formulation‚Äîbe it an algorithmic model, a mathematical equation system, or a graph structure.\n\n4. **Computational Tools/Data Structures**:\n   - After building the model, appropriate data structures (like trees, graphs, arrays) or computational tools (like MATLAB, Python, or optimization libraries) are used to simulate, compute, or optimize the solution.\n\n### Differences:\n| Aspect | Algorithm Competitions | University Modeling Competitions |\n|--------|------------------------|----------------------------------|\n| Focus  | Efficiency, correctness, speed | Accuracy, realism, scalability |\n| Tools Used | Code (C++, Python, etc.) | Simulation tools, statistics, sometimes code |\n| Output | Program solving a specific task | Report + possibly simulation/model |\n| Timeframe | Short (hours) | Long (days or weeks) |\n\nIn summary, the process of **modeling** in both settings shares a common foundation: identifying the right abstractions and formalizing them to enable effective computation or analysis."}],"tags":["algorithm","thought-process","model","simulation"]},"__N_SSG":true}