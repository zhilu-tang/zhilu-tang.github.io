{"pageProps":{"postMetadata":{"title":"Perception On Rolling Hash","description":"Key perceptions about Rolling Hash for Strings, pitfalls, and best practices","imgName":"perception-on-rolling-hash/perception-on-rolling-hash.png","date":"Jul 24, 2025","tags":["model","algorithm","simulation"],"keywords":["algorithm","perception","math"],"id":"on-rolling-hash"},"postContent":{"compiledSource":"var u=Object.defineProperty,m=Object.defineProperties;var g=Object.getOwnPropertyDescriptors;var l=Object.getOwnPropertySymbols;var s=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable;var t=(e,a,i)=>a in e?u(e,a,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[a]=i,n=(e,a)=>{for(var i in a||(a={}))s.call(a,i)&&t(e,i,a[i]);if(l)for(var i of l(a))o.call(a,i)&&t(e,i,a[i]);return e},h=(e,a)=>m(e,g(a));var p=(e,a)=>{var i={};for(var r in e)s.call(e,r)&&a.indexOf(r)<0&&(i[r]=e[r]);if(e!=null&&l)for(var r of l(e))a.indexOf(r)<0&&o.call(e,r)&&(i[r]=e[r]);return i};const layoutProps={},MDXLayout=\"wrapper\";function MDXContent(i){var r=i,{components:e}=r,a=p(r,[\"components\"]);return mdx(MDXLayout,h(n(n({},layoutProps),a),{components:e,mdxType:\"MDXLayout\"}),mdx(\"p\",null,mdx(\"img\",n({parentName:\"p\"},{src:\"perception-on-rolling-hash/perception-on-rolling-hash.png\",alt:\"Perception On Rolling Hash\"}))),mdx(\"h6\",null,\"Published on: \",mdx(\"strong\",{parentName:\"h6\"},\"Jul 24, 2025\")),mdx(\"h2\",null,\"\\u{1F511} Key Insights about Rolling Hash for Strings\"),mdx(\"p\",null,\"Rolling hash is a powerful technique for string processing that allows efficient computation and comparison of substring hashes. Here are the essential insights:\"),mdx(\"h3\",null,\"1. \",mdx(\"strong\",{parentName:\"h3\"},\"Core Principle\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Compute hash values for substrings using polynomial hashing\"),mdx(\"li\",{parentName:\"ul\"},\"Formula: \",mdx(\"inlineCode\",{parentName:\"li\"},\"hash(s[0...n-1]) = s[0]*p^(n-1) + s[1]*p^(n-2) + ... + s[n-1]*p^0\")),mdx(\"li\",{parentName:\"ul\"},\"Enable O(1) computation of any substring hash from precomputed prefix hashes\")),mdx(\"h3\",null,\"2. \",mdx(\"strong\",{parentName:\"h3\"},\"Rolling Property\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Given hash of substring \",mdx(\"inlineCode\",{parentName:\"li\"},\"s[i...j]\"),\", can compute hash of \",mdx(\"inlineCode\",{parentName:\"li\"},\"s[i+1...j+1]\"),\" in O(1)\"),mdx(\"li\",{parentName:\"ul\"},\"This property makes it ideal for sliding window algorithms\")),mdx(\"h3\",null,\"3. \",mdx(\"strong\",{parentName:\"h3\"},\"Preprocessing Advantage\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Compute all prefix hashes in O(n) time\"),mdx(\"li\",{parentName:\"ul\"},\"Any substring hash can be computed in O(1) time afterward\")),mdx(\"h2\",null,\"\\u26A0\\uFE0F Key Problems and Collision Issues\"),mdx(\"h3\",null,\"1. \",mdx(\"strong\",{parentName:\"h3\"},\"Hash Collisions\")),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-java\"}),`// Example of collision (simplified)\n// Two different strings might have same hash value\nString s1 = \"abc\", s2 = \"def\";\n// With certain BASE/MOD, hash(s1) might equal hash(s2)\n`)),mdx(\"h3\",null,\"2. \",mdx(\"strong\",{parentName:\"h3\"},\"Modulo Arithmetic Limitations\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Using finite MOD space means collisions are inevitable\"),mdx(\"li\",{parentName:\"ul\"},\"Birthday paradox: collisions occur more frequently than expected\")),mdx(\"h3\",null,\"3. \",mdx(\"strong\",{parentName:\"h3\"},\"Poor Parameter Choices\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Small BASE or MOD values increase collision probability\"),mdx(\"li\",{parentName:\"ul\"},\"Powers of 2 as BASE can lead to poor distribution\")),mdx(\"h2\",null,\"\\u{1F6E1}\\uFE0F Mitigation Strategies\"),mdx(\"h3\",null,\"1. \",mdx(\"strong\",{parentName:\"h3\"},\"Double Hashing\")),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-java\"}),`class DoubleHash {\n    private static final long BASE1 = 31, BASE2 = 37;\n    private static final long MOD1 = 1000000007, MOD2 = 1000000009;\n    \n    // Use pair of hashes to reduce collision probability\n    long hash1, hash2;\n    \n    // Compare both hash values for equality\n    public boolean equals(Object other) {\n        DoubleHash o = (DoubleHash) other;\n        return hash1 == o.hash1 && hash2 == o.hash2;\n    }\n}\n`)),mdx(\"h3\",null,\"2. \",mdx(\"strong\",{parentName:\"h3\"},\"Large Prime Parameters\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Use large primes for MOD (e.g., 10^9+7, 10^9+9)\"),mdx(\"li\",{parentName:\"ul\"},\"Choose BASE that's relatively prime to MOD\"),mdx(\"li\",{parentName:\"ul\"},\"Avoid powers of 2 or small primes for BASE\")),mdx(\"h3\",null,\"3. \",mdx(\"strong\",{parentName:\"h3\"},\"Verification for Critical Applications\")),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-java\"}),`// When hash matches, verify actual string equality if correctness is critical\nif (hash1 == hash2) {\n    // Only do expensive string comparison when hashes match\n    if (actualStringComparison(str1, str2)) {\n        // Truly equal\n    }\n}\n`)),mdx(\"h3\",null,\"4. \",mdx(\"strong\",{parentName:\"h3\"},\"Good Parameter Selection\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"BASE: Use prime numbers (commonly 31, 37, 41, 43)\"),mdx(\"li\",{parentName:\"ul\"},\"MOD: Use large primes (10^9+7, 10^9+9, or even larger)\"),mdx(\"li\",{parentName:\"ul\"},\"Avoid BASE=2, 10 which have poor distribution properties\")),mdx(\"h2\",null,\"\\u{1F3AF} When to Use Rolling Hash\"),mdx(\"h3\",null,\"\\u2705 Good Use Cases:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"String matching algorithms (Rabin-Karp)\"),mdx(\"li\",{parentName:\"ul\"},\"Finding duplicate substrings\"),mdx(\"li\",{parentName:\"ul\"},\"Palindrome detection\"),mdx(\"li\",{parentName:\"ul\"},\"Counting distinct substrings\"),mdx(\"li\",{parentName:\"ul\"},\"When approximate equality is acceptable\")),mdx(\"h3\",null,\"\\u274C Avoid When:\"),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Cryptographic security is required\"),mdx(\"li\",{parentName:\"ul\"},\"Exact string matching is critical without verification\"),mdx(\"li\",{parentName:\"ul\"},\"Very small strings where overhead doesn't pay off\")),mdx(\"h2\",null,\"\\u{1F4A1} Best Practices\"),mdx(\"h3\",null,\"1. \",mdx(\"strong\",{parentName:\"h3\"},\"Always Consider Collision Probability\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"For n strings, collision probability is roughly n\\xB2/(2*MOD)\"),mdx(\"li\",{parentName:\"ul\"},\"Choose MOD appropriately for your data size\")),mdx(\"h3\",null,\"2. \",mdx(\"strong\",{parentName:\"h3\"},\"Precompute Powers\")),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-java\"}),`// Precompute powers of BASE to avoid repeated calculations\nlong[] powers = new long[n];\npowers[0] = 1;\nfor (int i = 1; i < n; i++) {\n    powers[i] = (powers[i-1] * BASE) % MOD;\n}\n`)),mdx(\"h3\",null,\"3. \",mdx(\"strong\",{parentName:\"h3\"},\"Handle Negative Results\")),mdx(\"pre\",null,mdx(\"code\",n({parentName:\"pre\"},{className:\"language-java\"}),`// Always ensure hash values are positive\nlong hash = (computed_hash % MOD + MOD) % MOD;\n`)),mdx(\"h3\",null,\"4. \",mdx(\"strong\",{parentName:\"h3\"},\"Memory vs Time Tradeoff\")),mdx(\"ul\",null,mdx(\"li\",{parentName:\"ul\"},\"Decide whether to precompute all substring hashes or compute on demand\"),mdx(\"li\",{parentName:\"ul\"},\"Consider the specific problem constraints\")),mdx(\"p\",null,\"Rolling hash is a powerful tool when used correctly, but requires careful consideration of parameters and collision handling to ensure reliable results.\"))}MDXContent.isMDXComponent=!0;\n","scope":{}},"id":"on-rolling-hash","tags":["algorithm","thought-process","model","simulation"]},"__N_SSG":true}