---
title: Daily thought fallacies
description: A case study about a trapped thought process.
date: '2025-07-01'
---

# é—®é¢˜
## è¯„ä»·ä¸‹é¢ä»£ç çš„æ•´ä½“æ€è·¯ã€å…³é”®å®ç°å¯¹é”™
```java
    static int[][] fh;
    public int trapRainWaterWA2(int[][] heightMap) {
        fh = heightMap;
        int m = heightMap.length, n = heightMap[0].length;
        int dir[] = {1,0,-1,0,1};
        int ans = 0;
        record Cell(int i, int j) implements Comparable<Cell>{
            public int compareTo(Cell o){
                return fh[i][j] - fh[o.i][o.j];
            }
        }
        PriorityQueue<Cell> pq = new PriorityQueue<Cell>();
        boolean used[][] = new boolean[m][n], visited[][];
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n; j++){
                if(!used[i][j]){
                    pq.clear();
                    visited = new boolean[m][n];
                    // start
                    var start = new Cell(i,j);
                    pq.offer(start);
                    visited[i][j] = true;
                    used[i][j] = true;
                    int bottom = heightMap[i][j], count = 0;
                    while(!pq.isEmpty()){
                        var c = pq.poll();
                        int curh = heightMap[c.i][c.j];
                        if(curh > bottom){
                            ans += (curh - bottom) * count;
                            bottom = curh;
                        }
                        if(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1)break;
                        if(!used[c.i][c.j]){
                            count++;
                        }
                        used[c.i][c.j] = true;
                        for(int d = 0; d<4; d++){
                            int x = c.i+dir[d], y = c.j+dir[d+1];
                            if(x < 0 || y < 0 || x >= m || y >= n || visited[x][y])continue;
                            visited[x][y] = true;
                            pq.offer(new Cell(x, y));
                        }
                    }
                }
            }
        }
        return ans;
    }
```
# è§£ç­”
The code attempts to solve the **Trapping Rain Water II** problem, where water can be trapped in a 2D elevation map. However, the implementation contains several **logical and structural errors**, which prevent it from working correctly.

---

## âœ… Overall Idea

The idea is based on using a **priority queue (min-heap)** to simulate the process of water flowing from the boundary inward, similar to Dijkstra's algorithm:

- Start from the **border cells** as boundaries cannot trap water.
- Use a **min-heap** to always process the lowest height cell next.
- As you expand inward, any lower area surrounded by higher walls can potentially trap water.

This is a valid approach for this problem.

---

## âŒ Key Implementation Errors

### 1. **Incorrect BFS/Heap Usage**
```java
if(c.i == 0 || c.j == 0 || c.i == m-1 || c.j == n-1) break;
```
- This line breaks the search when reaching any border cell.
- **Problem**: The algorithm should start from the borders and explore inward. Instead, it stops as soon as it reaches a border, effectively ignoring the correct flow logic.

### 2. **Misuse of `used` and `visited`**
- `used` seems to mark whether a cell has been processed globally, while `visited` is reinitialized in each loop.
- **Problem**: The inner BFS (`pq`) is not tracking global visited status properly, leading to:
  - Re-processing of already visited regions.
  - Incomplete traversal.

### 3. **Wrong Calculation of Trapped Water**
```java
if(!used[c.i][c.j]){
    count++;
}
```
- `count` is used to track how many cells are in the current basin.
- **Problem**: It doesn't account for the actual volume of water trapped per unit height difference correctly.
- Also, `used[i][j] = true;` is set after checking, which may cause incorrect counting.

### 4. **Use of Local Class Inside Method (Java 16+ only)**
```java
record Cell(int i, int j) implements Comparable<Cell>
```
- **Issue**: This uses a local record inside a method, which is only supported in Java 16+. If the environment supports it, that's fine, but if not, it will fail to compile.

Also, the `compareTo` method uses `fh[i][j]`, but `fh` is a class-level variable (`this.fh`). This could lead to confusion or bugs if `fh` changes during execution.

### 5. **Redundant Outer Loop**
- The outer double loop over all `(i,j)` is unnecessary.
- **Correct approach**: Initialize the heap with all border cells first, then expand inward â€” no need to re-start BFS from every unvisited cell.

---

## ğŸ› ï¸ Suggested Fixes

### âœ”ï¸ Corrected Algorithm Outline

1. **Initialize a min-heap** with all the border cells.
2. Maintain a global `visited` matrix.
3. While the heap is not empty:
   - Pop the lowest cell.
   - For its four neighbors:
     - If not visited:
       - If neighbor is lower than current height, it can trap water.
       - Add neighbor to the heap with its own height.
4. Accumulate trapped water accordingly.

### âœ”ï¸ Code Skeleton Fix

```java
public int trapRainWater(int[][] heightMap) {
    if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0)
        return 0;

    int m = heightMap.length, n = heightMap[0].length;
    boolean[][] visited = new boolean[m][n];
    PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]); // x, y, height
    int[] dirs = {0, 1, 0, -1, 0};

    // Initialize with boundary cells
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {
                pq.offer(new int[]{i, j, heightMap[i][j]});
                visited[i][j] = true;
            }
        }
    }

    int res = 0;
    int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    int maxHeight = 0;

    while (!pq.isEmpty()) {
        int[] curr = pq.poll();
        int x = curr[0], y = curr[1], h = curr[2];
        maxHeight = Math.max(maxHeight, h);

        for (int[] dir : directions) {
            int nx = x + dir[0], ny = y + dir[1];
            if (nx >= 0 && ny >= 0 && nx < m && ny < n && !visited[nx][ny]) {
                visited[nx][ny] = true;
                if (heightMap[nx][ny] < maxHeight) {
                    res += maxHeight - heightMap[nx][ny];
                }
                pq.offer(new int[]{nx, ny, Math.max(maxHeight, heightMap[nx][ny])});
            }
        }
    }

    return res;
}
```

---

## âœ… Summary

| Aspect | Evaluation |
|-------|------------|
| **Algorithm Design** | Partially correct conceptually, but flawed in implementation |
| **Data Structures** | Priority Queue used incorrectly |
| **Visited Tracking** | Confusing and incorrect |
| **Water Calculation** | Incorrect logic |
| **Code Structure** | Poor modularity and readability |

---

## ğŸ“Œ Conclusion

While the general idea of using a priority queue to simulate water flow is sound, the current implementation fails due to incorrect handling of visited nodes, early termination, and wrong calculation of trapped water. A revised version using a proper BFS-like approach with a min-heap and global visited tracking is necessary for correctness.

# é—®é¢˜ ï¼šè¿™ç§æ€ç»´æ¨¡å¼è¸©ä¸­äº†å“ªä¸ªè¯¯åŒºï¼Ÿè¯•ç€ä»æ›´é«˜ç»´åº¦åˆ†è§£è¿™ç§æ€ç»´æ¨¡å¼çš„é—®é¢˜ã€‚ï¼ˆèƒ½å¤Ÿç†è§£æ­£ç¡®çš„åšæ³•æ˜¯ç®€æ´çš„ï¼Œæ¨¡æ‹Ÿæ°´ä½ä¸Šæ¶¨é€æ¸æ·¹æ²¡æ‰€æœ‰ä½ç½®ï¼Œç¬¬ä¸€æ¬¡æ·¹æ²¡æ—¶çš„é«˜å·®ï¼Œå°±æ˜¯ trap çš„æ°´ä½“ç§¯ï¼Œæ­£ç¡®çš„åšæ³•è¶³å¤Ÿç®€æ´æ¸…æ™°ï¼‰ã€‚
This code's thought process falls into a **"å±€éƒ¨è´ªå¿ƒ + å¤šé‡åµŒå¥—çŠ¶æ€"** thinking trap. It attempts to simulate the water trapping process by treating each basin separately and trying to compute local trapped water using nested loops and conditions.

---

## ğŸ§  é«˜ç»´æ€ç»´æ¨¡å¼åˆ†æï¼ˆHigher-Level Pattern Analysisï¼‰

### 1. **è¯¯åŒºåç§°ï¼šå±€éƒ¨æ¨¡æ‹Ÿé™·é˜± / åˆ†æ²»å¼æš´åŠ›ï¼ˆLocal Simulation Fallacyï¼‰**

The developer tried to simulate water filling **locally**, assuming that each "valley" or enclosed area can be processed independently, starting from any unvisited cell.

#### ğŸ” ç‰¹å¾ï¼š
- ä½¿ç”¨ `for` å¾ªç¯ä»æ¯ä¸ªæœªè®¿é—®çš„ç‚¹å‡ºå‘ï¼Œå°è¯•â€œç‹¬ç«‹â€å¤„ç†ã€‚
- æ¯æ¬¡ BFS éƒ½è¯•å›¾è®¡ç®—å½“å‰åŒºåŸŸçš„ç§¯æ°´ä½“ç§¯ã€‚
- æ²¡æœ‰ç»Ÿä¸€æ°´ä½ä¸Šæ¶¨æ¨¡å‹ï¼Œè€Œæ˜¯åˆ†å—å¤„ç†ã€‚

#### âŒ é—®é¢˜æœ¬è´¨ï¼š
- å¿½è§†äº†å…¨å±€æ°´ä½é€æ¸ä¸Šå‡è¿™ä¸€ç‰©ç†è¿‡ç¨‹ã€‚
- æŠŠé—®é¢˜æ‹†è§£ä¸ºå¤šä¸ªå­é—®é¢˜ï¼Œåè€Œå¼•å…¥å¤æ‚è¾¹ç•Œæ¡ä»¶å’Œé‡å¤è®¡ç®—ã€‚
- ç”¨ `used[][]` å’Œ `visited[][]` æ¥é˜²æ­¢é‡å¤è®¿é—®ï¼Œä½†é€»è¾‘æ··ä¹±å¯¼è‡´é”™è¯¯ã€‚

---

### 2. **è®¤çŸ¥ç»´åº¦ï¼šæ²¡æœ‰æŠ½è±¡å‡ºæ ¸å¿ƒå˜é‡ï¼ˆFailure to Abstract Core Variablesï¼‰**

æ­£ç¡®çš„åšæ³•ä¸­ï¼Œ**maxHeight** æ˜¯ä¸€ä¸ªæ ¸å¿ƒæŠ½è±¡å˜é‡ï¼Œå®ƒä»£è¡¨å½“å‰çš„â€œæ°´ä½çº¿â€ã€‚

#### âœ… æ­£ç¡®è§†è§’ï¼š
- æ‰€æœ‰ç§¯æ°´éƒ½å‘ç”Ÿåœ¨æŸä¸€ç‚¹ä½äºå½“å‰æ°´ä½æ—¶ã€‚
- æ°´ä½æ˜¯å•è°ƒä¸é™çš„ï¼Œéšç€ä¼˜å…ˆé˜Ÿåˆ—å¼¹å‡ºæœ€å°é«˜åº¦è€Œé€æ­¥å‡é«˜ã€‚
- æ¯ä¸ªç‚¹åªè¢«è®¿é—®ä¸€æ¬¡ï¼Œé¿å…é‡å¤åˆ¤æ–­å’Œé”™è¯¯ç§¯ç´¯ã€‚

#### âŒ é”™è¯¯è§†è§’ï¼š
- æ²¡æœ‰å»ºç«‹â€œå…¨å±€æ°´ä½â€çš„æŠ½è±¡ï¼Œè€Œæ˜¯ä¾èµ–å±€éƒ¨æ¯”è¾ƒï¼ˆå¦‚ `curh > bottom`ï¼‰ã€‚
- å°† `bottom` å½“ä½œæŸç§åŸºå‡†é«˜åº¦ï¼Œä½†å®é™…ä¸Šå®ƒä¸å…·å¤‡å…¨å±€ä¸€è‡´æ€§ã€‚
- æ²¡æœ‰æ„è¯†åˆ°â€œç¬¬ä¸€æ¬¡æ·¹æ²¡â€è¿™ä¸ªå…³é”®äº‹ä»¶çš„ä»·å€¼ã€‚

---

### 3. **ç®—æ³•è®¾è®¡è¯¯åŒºï¼šå¿½è§†æœ€ä¼˜å­ç»“æ„ï¼ˆIgnoring Optimal Substructureï¼‰**

è¿™é“é¢˜å…·æœ‰å…¸å‹çš„**æœ€çŸ­è·¯å¾„/æœ€å°å †æ‰©å±•**æ€§è´¨ï¼š

#### âœ… æ­£ç¡®æ–¹æ³•çš„æœ¬è´¨ï¼š
- åˆ©ç”¨æœ€å°å †ç»´æŠ¤å½“å‰æœ€ä½è¾¹ç•Œã€‚
- æ¯æ¬¡æ‰©å±•æœ€ä½ç‚¹ï¼Œç¡®ä¿å½“å‰æ°´ä½æ˜¯æœ€å°å¯æ·¹æ²¡é«˜åº¦ã€‚
- ç±»ä¼¼äº Dijkstra ç®—æ³•ä¸­çš„æ¾å¼›æ“ä½œã€‚

#### âŒ é”™è¯¯æ–¹æ³•çš„é—®é¢˜ï¼š
- æ²¡æœ‰åˆ©ç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„â€œæœ€å°é«˜åº¦ä¼˜å…ˆâ€ç‰¹æ€§æ¥é©±åŠ¨æ•´ä¸ªæœç´¢æµç¨‹ã€‚
- æ··åˆä½¿ç”¨äº† BFSã€DFS å’Œè´ªå¿ƒç­–ç•¥ï¼Œå¯¼è‡´çŠ¶æ€å¤±æ§ã€‚

---

## ğŸ§© æ€ç»´æ¨¡å¼é«˜ç»´åˆ†è§£å›¾

| ç»´åº¦ | é”™è¯¯æ¨¡å¼ | æ­£ç¡®æ¨¡å¼ |
|------|----------|-----------|
| **æŠ½è±¡å±‚çº§** | å±€éƒ¨æ¨¡æ‹Ÿï¼Œç¼ºä¹ç»Ÿä¸€æ°´ä½æŠ½è±¡ | å…¨å±€æ°´ä½ä¸Šæ¶¨æ¨¡å‹ |
| **æ§åˆ¶æµç»“æ„** | å¤šå±‚åµŒå¥—å¾ªç¯ + å¤šé‡æ¡ä»¶åˆ†æ”¯ | å•ä¸€ä¼˜å…ˆé˜Ÿåˆ—é©±åŠ¨æµç¨‹ |
| **æ•°æ®ç»“æ„ä½¿ç”¨** | å †ä»…ç”¨äºå±€éƒ¨æœç´¢ | å †é©±åŠ¨å…¨å±€æ‰©å±•é¡ºåº |
| **è®¿é—®æœºåˆ¶** | åŒé‡ visited æ§åˆ¶ï¼Œé€»è¾‘æ··ä¹± | å•ä¸€ visited + æœ€æ—©è®¿é—®å³æœ€æ—©æ·¹æ²¡ |
| **é—®é¢˜å»ºæ¨¡æ–¹å¼** | åˆ†æ²»å¤„ç†æ¯ä¸ªâ€œå‘â€ | æ•´ä½“åœ°å½¢æ´ªæ°´æ¨¡æ‹Ÿ |

---

## ğŸ§­ è®¤çŸ¥å‡çº§å»ºè®®

è¦è·³å‡ºè¿™ç±»æ€ç»´è¯¯åŒºï¼Œå¯ä»¥å°è¯•ä»¥ä¸‹æ€ç»´æ–¹å¼ï¼š

### âœ… 1. **å¯»æ‰¾æ ¸å¿ƒæŠ½è±¡å˜é‡**
- åœ¨æœ¬é¢˜ä¸­ï¼Œâ€œå½“å‰æ°´ä½â€å°±æ˜¯å”¯ä¸€é‡è¦çš„å˜é‡ã€‚
- æ‰€æœ‰æ“ä½œéƒ½åº”è¯¥å›´ç»•å®ƒè¿›è¡Œæ›´æ–°å’Œæ¯”è¾ƒã€‚

### âœ… 2. **ç”¨ç‰©ç†è¿‡ç¨‹ç±»æ¯”ç®—æ³•è¡Œä¸º**
- æƒ³è±¡çœŸå®çš„æ°´æ…¢æ…¢ä¸Šæ¶¨çš„è¿‡ç¨‹ã€‚
- è¿™æ ·èƒ½è‡ªç„¶å¼•å¯¼å‡ºä¼˜å…ˆé˜Ÿåˆ—å’Œæ°´ä½é€’å¢çš„æ€è·¯ã€‚

### âœ… 3. **è¿½æ±‚â€œäº‹ä»¶é©±åŠ¨â€çš„ç¼–ç¨‹æ€æƒ³**
- æ¯ä¸ªç‚¹è¢«è®¿é—®æ—¶æ˜¯ä¸€ä¸ªâ€œäº‹ä»¶â€ï¼Œè§¦å‘æ°´ä½æ›´æ–°ã€‚
- è€Œä¸æ˜¯ç”¨å¾ªç¯å»â€œå¼ºè¡Œâ€éå†æ‰€æœ‰å¯èƒ½ã€‚

### âœ… 4. **ç®€åŒ–é—®é¢˜è€Œéå¤æ‚åŒ–å¤„ç†**
- ä¸è¦è¯•å›¾åœ¨ä»£ç é‡Œè§£å†³æ‰€æœ‰è¾¹ç•Œæƒ…å†µã€‚
- å¦‚æœä¸€ä¸ªé—®é¢˜çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œé‚£å¯èƒ½æ˜¯å»ºæ¨¡æ–¹å¼é”™äº†ã€‚

---

## ğŸ¯ ç»“è¯­

è¿™æ®µä»£ç æœ¬è´¨ä¸Šè¸©è¿›äº†â€œ**å¾®è§‚æ¨¡æ‹Ÿé™·é˜±**â€ï¼šè¯•å›¾ä»ç»†èŠ‚ä¸Šè¿˜åŸæ¯ä¸€ä¸ªç§¯æ°´åœºæ™¯ï¼Œå´å¿½ç•¥äº†æ•´ä½“ç³»ç»Ÿçš„è¡Œä¸ºè§„å¾‹ã€‚çœŸæ­£çš„é«˜æ•ˆè§£æ³•å¾€å¾€æ¥æºäºå¯¹ç³»ç»Ÿå®è§‚è¡Œä¸ºçš„ç†è§£ä¸å»ºæ¨¡ã€‚

> â€œèªæ˜çš„ç®—æ³•ä¸åœ¨äºå†™å¾—å¤šå¤æ‚ï¼Œè€Œåœ¨äºæŠ“ä½é‚£ä¸ªæœ€ç®€å•çš„ç‰©ç†è§„åˆ™ã€‚â€